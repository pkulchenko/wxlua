<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<HTML>
<HEAD>
  <META name="generator" content=
  "HTML Tidy for Linux (vers 25 March 2009), see www.w3.org">
  <META content="text/html; charset=us-ascii" http-equiv="content-type">

  <TITLE>wxLua Manual</TITLE>
  <META content="John Labenski" name="author">
  <META content="wxLua Manual" name="description">
  <LINK rel="stylesheet" type="text/css" href="wxlua.css">
</HEAD>

<BODY>
  <H1>wxLua 2.8.12 - Manual</H1>

  <P><A href="http://wxlua.sourceforge.net">wxLua</A> is a <A href=
  "http://www.lua.org">Lua</A> scripting language wrapper around the <A href=
  "http://www.wxwidgets.org">wxWidgets</A> cross-platform C++ GUI library. It
  consists of two IDE type editors that can edit, debug, and run Lua programs
  (wxLua and wxLuaEdit), an executable for running standalone wxLua scripts
  (wxLuaFreeze), a Lua module that may be loaded using <CODE class=
  "codelua">require("wx")</CODE> when using the standard Lua executable, and a
  library for extending C++ programs with a fast, small, fully embeddable
  scripting language.</P>

  <P>Lua is a small scripting language written in ANSI C that can load and run
  interpreted scripts as either files or strings. The Lua language is fast,
  dynamic, and easy to learn. Lua contains a limited number of data types,
  mainly numbers, booleans, strings, functions, tables, and userdata. Perhaps
  the most powerful feature of the Lua language is that tables can be used as
  either numerically indexed arrays or associative arrays that can
  cross-reference any variable type to any other variable type.</P>

  <P>wxLua adds to this small and elegant language the power of the C++
  wxWidgets cross-platform GUI library. This includes the ability to create
  complex user interface dialogs, file and image manipulation, drawing,
  sockets, displaying HTML, and printing to name a few. You can use as much or
  as little of wxWidgets as you like and C++ developers can trim down the size
  the bindings by turning off preprocessor directives.</P>

  <P>Additionally, wxLua adds a library for manipulating the bits of integer
  numbers using the Bitlib library from Reuben Thomas.</P>

  <H3>References:</H3>

  <TABLE border="0" summary="">
    <TR>
      <TD>wxLua website</TD>

      <TD>-</TD>

      <TD><A href=
      "http://wxlua.sourceforge.net">http://wxlua.sourceforge.net</A></TD>
    </TR>

    <TR>
      <TD>wxLua Sourceforge page</TD>

      <TD>-</TD>

      <TD><A href=
      "http://sourceforge.net/projects/wxlua">http://sourceforge.net/projects/wxlua</A></TD>
    </TR>

    <TR>
      <TD>Lua website</TD>

      <TD>-</TD>

      <TD><A href="http://www.lua.org">http://www.lua.org</A></TD>
    </TR>

    <TR>
      <TD>wxWidgets website</TD>

      <TD>-</TD>

      <TD><A href="http://www.wxwidgets.org">http://www.wxwidgets.org</A></TD>
    </TR>

    <TR>
      <TD>Bitlib library</TD>

      <TD>-</TD>

      <TD><A href=
      "http://rrt.sc3d.org/Software/Lua/">http://rrt.sc3d.org/Software/Lua/</A></TD>
    </TR>

    <TR>
      <TD>Mailing list</TD>

      <TD>-</TD>

      <TD>wxlua-users@lists.sourceforge.net</TD>
    </TR>
  </TABLE>

  <H2>Table of Contents</H2>

  <DIV class="contents">
    <OL>
      <LI><A href="wxlua.html#C1">1 - Version Information</A></LI>

      <LI><A href="wxlua.html#C2">2 - Requirements</A></LI>

      <LI><A href="wxlua.html#C3">3 - Brief Introduction to Lua</A></LI>

      <LI><A href="wxlua.html#C4">4 - Bit Library</A></LI>

      <LI>
        <A href="wxlua.html#C5">5 - Programming in wxLua</A>

        <OL>
          <LI><A href="wxlua.html#C5.1">5.1 - Naming, location, and usage of
          the wxWidgets objects declared in the C++ header files in the wx Lua
          table</A></LI>
        </OL>
      </LI>

      <LI>
        <A href="wxlua.html#C6">6 - wxLua Samples and How to Run Them</A>

        <OL>
          <LI><A href="wxlua.html#C6.1">6.1 - How to Run the Samples</A></LI>

          <LI><A href="wxlua.html#C6.2">6.2 - Provided Samples</A></LI>
        </OL>
      </LI>

      <LI>
        <A href="wxlua.html#C7">7 - wxLua Applications</A>

        <OL>
          <LI><A href="wxlua.html#C7.1">7.1 - wxLua</A></LI>

          <LI><A href="wxlua.html#C7.2">7.2 - wxLuaEdit</A></LI>

          <LI><A href="wxlua.html#C7.3">7.3 - wxLuaFreeze</A></LI>
        </OL>
      </LI>

      <LI>
        <A href="wxlua.html#C8">8 - wxLua Utils</A>

        <OL>
          <LI><A href="wxlua.html#C8.1">8.1 - bin2c.lua</A></LI>
        </OL>
      </LI>

      <LI><A href="wxlua.html#C9">9 - wxLua Sourcecode Modules</A></LI>

      <LI>
        <A href="wxlua.html#C10">10 - wxLua C++ Programming Guide</A>

        <OL>
          <LI><A href="wxlua.html#C10.1">10.1 - Data stored in Lua's
          LUA_REGISTRYINDEX table</A></LI>

          <LI><A href="wxlua.html#C10.2">10.2 - Functions to Create a
          wxLuaState</A></LI>

          <LI><A href="wxlua.html#C10.3">10.3 - Using a wxLuaState</A></LI>
        </OL>
      </LI>
    </OL>
  </DIV>

  <H2><A name="C1" id="C1"></A>1 - Version Information</H2>

  <UL>
    <LI>The wxLua version number is set to the stable version of wxWidgets that
    it has been updated to.

      <UL>
        <LI>It may also compile with newer versions of wxWidgets as well as
        older ones.</LI>
      </UL>
    </LI>

    <LI>Lua 5.1.4

      <UL>
        <LI>wxLua uses an unmodified copy of Lua 5.1.4.</LI>

        <LI>However, official patches on www.lua.org are applied as they are
        released.</LI>

        <LI>Any program that works using the official release of Lua will work
        in wxLua.</LI>
      </UL>
    </LI>

    <LI>wxWidgets 2.8.12

      <UL>
        <LI>The interface files have #ifdefs for 2.6, but they are not
        maintained anymore since in some cases the complexity of maintaining
        backwards compatibility is not worth it and it is better to take
        advantage of the fixes and additions to newer versions of wxWidgets.
        With a little work you may be able to resurrect it to work with
        wxWidgets 2.6.</LI>

        <LI>Note for wxWidgets &lt; 2.9 : wxLua makes use of the
        wxStyledTextCtrl contrib library in wxWidgets/contrib/src/stc. You need
        to have compiled this into a library if you want to compile the wxLua
        apps. In wxWidgets &gt;= 2.9 the wxStyledTextCtrl is now part of the
        main distribution.</LI>

        <LI>The wxLua library links to these wxWidgets libs: stc, xrc, html,
        media, adv, net, xml, core, base, tiff, jpeg, png, zlib, regex,
        expat.</LI>

        <LI>See install.html for more information.</LI>
      </UL>
    </LI>
  </UL>

  <H2><A name="C2" id="C2"></A>2 - Requirements</H2>An end user of wxLua can
  use the binary packages of wxLua and everything that's needed is contained
  within it. C++ programmers or users on platforms that we don't provide
  binaries for will need a development library of wxWidgets; typically the
  source code that you have compiled on your system. More information about
  compiling wxLua is contained in the <A href="install.html">install.html</A>
  file and on <A href=
  "http://wxlua.sourceforge.net/">http://wxlua.sourceforge.net</A>.

  <H2><A name="C3" id="C3"></A>3 - Brief Introduction to Lua</H2>This short
  primer is meant to give you a good enough feel for Lua that you will be able
  to understand the sample programs and begin to write your own. It assumes
  that you have a cursory understanding of general programming techniques. You
  should, in any case, read the documentation at <A href=
  "http://www.lua.org">www.lua.org</A>.<BR>

  <UL>
    <LI>
      <B>Comments</B>

      <UL>
        <LI>Single line comments

          <UL>
            <LI><CODE class="codelua">-- rest of line is commented</CODE></LI>
          </UL>
        </LI>

        <LI>Multiple line block or inline comments

          <UL>
            <LI><CODE class="codelua">--[[ multiple line or inline comment
            ]]</CODE></LI>
          </UL>
        </LI>
      </UL>
    </LI>

    <LI>
      <B>Variables</B>

      <UL>
        <LI>Variables are not permanently typed and you can freely overwrite
        them with other values or types, there is no "const" keyword.</LI>

        <LI>Variables are global unless you put the keyword <CODE class=
        "codelua">local</CODE> in front of them, this is sometimes good
        practice.</LI>

        <LI>The scope of <CODE class="codelua">local</CODE> variables is
        limited to the current scope and its children.</LI>

        <LI>Local variables can be harder to debug because they are stored on
        the stack and you need the Lua debug functions to resolve the
        name.</LI>

        <LI>Local variables are faster than global variables because they do
        not require a table lookup for use.</LI>

        <LI>A <CODE class="codelua">local</CODE> variable created with the same
        name as a global variable temporarily supersedes the global.</LI>

        <LI>Use the function <CODE class="codelua">type(var_name)</CODE> to get
        the variable type as a string.

          <UL>
            <LI>The 8 variables types are: "nil", "boolean", "number",
            "string", "table", "function", "userdata", "thread"</LI>
          </UL>
        </LI>
      </UL>
    </LI>

    <LI>
      <B>Lua Types</B>

      <UL>
        <LI>
          <B>nil</B> : A special value meaning NULL or nothing.

          <UL>
            <LI><CODE class="codelua">a = nil; local b; print(a, b, type(a),
            type(b))</CODE> ; prints "nil nil nil nil"</LI>

            <LI>Variables that have not been assigned a value are <CODE class=
            "codelua">nil</CODE> and any variable can be reset back to
            <CODE class="codelua">nil</CODE> at any time to allow the Lua
            garbage collector to delete them if there are no other references
            to it.</LI>

            <LI>This value is often returned for functions that fail.</LI>

            <LI>You can provide an inline alternative to <CODE class="codelua">
              nil</CODE> using the <CODE class="codelua">or</CODE> keyword
              since <CODE class="codelua">nil</CODE> evaluates to false.

              <UL>
                <LI><CODE class="codelua">print(tonumber("a"), tonumber("a") or
                1)</CODE> ; prints "nil 1"</LI>
              </UL>
            </LI>
          </UL>
        </LI>

        <LI>
          <B>boolean</B> : <CODE class="codelua">true</CODE> or <CODE class=
          "codelua">false</CODE>

          <UL>
            <LI><CODE class="codelua">a = true; b = false; print(a, b, type(a),
            type(b))</CODE> ; prints "true false boolean boolean"</LI>

            <LI>Note that <CODE class="codelua">nil</CODE> works as
            <CODE class="codelua">false</CODE>, but the number 0 evaluates as
            <CODE class="codelua">true</CODE> since it has a value, i.e. not
            <CODE class="codelua">nil</CODE>, use <CODE class="codelua">(a ~=
            0)</CODE>.</LI>
          </UL>

          <UL>
            <LI><CODE class="codelua">a = 0; if a then print(a) end</CODE> ;
            prints "0" since the variable "<CODE class="codelua">a</CODE>"
            evaluates to <CODE class="codelua">true</CODE>.</LI>
          </UL>
        </LI>
      </UL>

      <UL>
        <LI>
          <B>number</B> : All numbers in Lua are double valued floating point
          numbers.

          <UL>
            <LI><CODE class="codelua">a = 1; b = 3.14; print(a, b, type(a),
            type(b))</CODE> ; prints "1 3.14 number number"</LI>

            <LI><CODE class="codelua">n = (1E1 * 3.14 * math.sin(1) /
            4)*math.pow(2.5e-1, 4)</CODE></LI>

            <LI>Variables can be coerced into numbers using the function
            <CODE class="codelua">tonumber(variable)</CODE> which returns
            <CODE class="codelua">nil</CODE> on failure.</LI>

            <LI>Additional math functions are in the <CODE class=
            "codelua">math</CODE> table.</LI>
          </UL>
        </LI>

        <LI>
          <B>string</B> : Strings in Lua can have embedded nulls "\0" and use
          the same escape characters as C.

          <UL>
            <LI><CODE class="codelua">a = "hello"; b = a; b = "hi"; print(a, b,
            #a, type(a))</CODE> ; prints "hello hi 5 string"</LI>

            <LI>Strings are internally hashed by Lua so that there is only one
            copy of a particular string stored at any one time no matter how
            many variables reference it.</LI>

            <LI>String variables are copy on write and the example above shows
            that overwriting "b" does not change "a".</LI>

            <LI><CODE class="codelua">s = "How are 'you'!"</CODE> or
            <CODE class="codelua">s = 'How\tare "You"!\n'</CODE> are both valid
            since either " or ' can be used to quote strings. ('\t' = tab, '\n'
            = line feed)</LI>

            <LI><CODE class="codelua">s = [[How are "'you'"!]]</CODE> means
            take everything including new lines and whitespace literally.</LI>

            <LI>Concatenate two strings using the <CODE class=
            "codelua">..</CODE> operator

              <UL>
                <LI><CODE class="codelua">str1 = "hello"; str2 = "number"; str3
                = str1.." "..str2.." "..tostring(2).."!"</CODE></LI>

                <LI>Numbers can be coerced into strings as <CODE class=
                "codelua">("A "..2)</CODE>, but not <CODE class="codelua">(2.."
                A")</CODE> since the left hand side of the <CODE class=
                "codelua">..</CODE> operator must be a string.</LI>

                <LI>Many strings should be concatenated together by putting
                them into a table array using <CODE class=
                "codelua">table.insert()</CODE> and then <CODE class=
                "codelua">table.concat()</CODE> called to create the single
                string result. The concatenation operator <CODE class=
                "codelua">..</CODE> is slower because each intermediary string
                has to be reallocated and hashed. The <CODE class=
                "codelua">table.concat()</CODE> method only has to allocate and
                hash the resultant string once and its speed is quite
                competitive to other scripting languages.</LI>
              </UL>
            </LI>

            <LI>Variables can be coerced into strings using the function
            <CODE class="codelua">tostring(variable)</CODE> which returns
            <CODE class="codelua">nil</CODE> on failure.</LI>

            <LI>Additional string functions are in the <CODE class=
            "codelua">string</CODE> table.</LI>
          </UL>
        </LI>

        <LI>
          <B>table</B> : Tables can be indexed by and hold values of numbers,
          strings, functions, userdata, other tables...

          <UL>
            <LI>
              <CODE class="codelua">a = {5}; b = a; b[1] = 6; print(a, b, a[1],
              b[1], b[2], type(a), type(b))</CODE>

              <UL>
                <LI>prints "table: 01780F98 table: 01780F98 6 6 nil table
                table"</LI>
              </UL>

              <UL>
                <LI>Printing a table is the same as calling <CODE class=
                "codelua">tostring(t)</CODE> on the table which displays the
                variable type and its memory address.</LI>

                <LI>Assigning a variable to an existing table does not copy the
                table and you can use either variable to access and modify the
                elements.</LI>
              </UL>
            </LI>

            <LI>
              <CODE class="codelua">t = {}</CODE> creates an empty table.

              <UL>
                <LI>You must declare a variable as a table before using its
                indexes.</LI>

                <LI>The array part of a table are the contiguous integer
                indexes starting from 1.</LI>
              </UL>
            </LI>

            <LI>
              <CODE class="codelua">t = { ["a"] = 5, "first", "second", B = 7
              }; print(t.a, t["a"], t[0], t[1], t[2], t.B, t.b, t.c)</CODE>

              <UL>
                <LI>prints "5 5 nil first second 7 nil nil"</LI>

                <LI>Set values as : <CODE class="codelua">t.a = 2; t["a"] = 3;
                t[10] = 4</CODE></LI>

                <LI>Elements are automatically created when assigning new
                values to elements that don't already exist and accessing
                elements that don't exist returns <CODE class=
                "codelua">nil</CODE>.</LI>

                <LI>Clear values by setting them to <CODE class=
                "codelua">nil</CODE>, e.g. <CODE class="codelua">t.a =
                nil</CODE></LI>

                <LI>The length operator <CODE class="codelua">#t</CODE> returns
                2 since there are only two contiguous integer table indexes
                starting from 1 even though in this case there are actually 4
                entries in the table.

                  <UL>
                    <LI>The length of a table used as an array with holes (nil
                    values) is undefined.</LI>

                    <LI>The only guarantee is that the value at <CODE class=
                    "codelua">t[#t+1]</CODE> will be <CODE class=
                    "codelua">nil</CODE>.</LI>
                  </UL>
                </LI>

                <LI>Lua table arrays have a starting index of 1.</LI>

                <LI>
                  <CODE class="codelua">for k, v in ipairs(t) do print(k, v)
                  end</CODE> ; Note: (k = key, v = value)

                  <UL>
                    <LI>prints only the array values : "1 first" and "2
                    second"</LI>
                  </UL>
                </LI>

                <LI>
                  <CODE class="codelua">for k, v in pairs(t) do print(k, v)
                  end</CODE> ; Note: (k = key, v = value)

                  <UL>
                    <LI>prints all table values unordered : "1 first", "2
                    second", "a 5", "B 7"</LI>
                  </UL>
                </LI>
              </UL>
            </LI>

            <LI>Functions defined by Lua are placed into tables, a namespace if
            you will, to keep the global namespace uncluttered.

              <UL>
                <LI>See <CODE class="codelua">table.XXX, string.XXX, math.XXX,
                os.XXX</CODE> etc. in the Lua documentation.</LI>

                <LI>wxLua places the wxWidgets bindings into the <CODE class=
                "codelua">wx.XXX</CODE> table "namespace".</LI>

                <LI>The global table is called <CODE class="codelua">_G</CODE>
                and you can display it as you would any table using

                  <UL>
                    <LI><CODE class="codelua">for k, v in pairs(_G) do print(k,
                    v) end</CODE></LI>
                  </UL>
                </LI>
              </UL>
            </LI>

            <LI>Additional table functions are in the <CODE class=
            "codelua">table</CODE> table.</LI>
          </UL>
        </LI>

        <LI>
          <B>userdata</B> :

          <UL>
            <LI>This is a pointer to a C/C++ object that cannot be created by
            itself in Lua.</LI>

            <LI>A metatable (see Lua documentation) may be assigned to it to
            allow it to act as a table or be called as a function, among other
            things.</LI>

            <LI>This is the data type that wxLua uses wrap wxWidgets C++
            objects that are pushed into Lua.</LI>

            <LI>wxLua assigns a metatable to the Lua userdata when created
            which contains the list of functions which may be called on the
            object.</LI>
          </UL>
        </LI>

        <LI>
          <B>function</B> :

          <UL>
            <LI><CODE class="codelua">function f(a, b) return a+b end; print(f,
            f(1,2), type(f))</CODE></LI>

            <LI>
              <CODE class="codelua">f = function (a, b) return a+b end;
              print(f, f(1,2), type(f))</CODE>

              <UL>
                <LI>Both lines above print "function: 01DE2AF8 3 function"</LI>

                <LI>Printing a function is the same as calling <CODE class=
                "codelua">tostring(f)</CODE> on the function which displays the
                variable type and its memory address.</LI>
              </UL>
            </LI>

            <LI>Functions can return multiple values and be passed more or less
            variables than specified.</LI>

            <LI>Unassigned inputs are set to <CODE class="codelua">nil</CODE>
            and unassigned return values are thrown out.</LI>

            <LI>Functions can be assigned to variables or put into tables.

              <UL>
                <LI><CODE class="codelua">t = {}; t["Add"] = f; print(t.Add(1,
                2), t.Add)</CODE> ; prints "3 function: 01DE2AF8</LI>

                <LI>If you plan on putting a function into a table you may want
                to declare the function local since it won't be garbage
                collected until the table is garbage collected or the table's
                index to the function is set to <CODE class=
                "codelua">nil</CODE>.</LI>
              </UL>
            </LI>
          </UL>

          <UL>
            <LI>Boolean, number, and string parameters are passed to functions
            by value and changes to them do not modify the original.</LI>

            <LI>Tables and userdata are passed to functions by reference and
            changes to them do modify the original variable.</LI>
          </UL>

          <DIV style="margin-left: 2em">
            <UL>
              <LI><CODE class="codelua">function table_append(t, v) t[#t+1] =
              v; v = 0; end; tbl = {}; item = "hello"; table_append(tbl, item);
              print(tbl[#tbl], item)</CODE></LI>

              <LI>prints "hello hello", i.e. <CODE class="codelua">tbl[1] ==
              "hello"</CODE> and the variable "<CODE class=
              "codelua">item</CODE>" still equals "hello" and was not
              changed.</LI>
            </UL>
          </DIV>
        </LI>
      </UL>
    </LI>

    <LI>
      <B>Operators</B>

      <UL>
        <LI>Relational : <CODE class="codelua">== ~= &lt; &gt; &lt;=
        &gt;=</CODE> (Note: not equal is <CODE class="codelua">~=</CODE>)</LI>

        <LI>Logical: <CODE class="codelua">and, or, not</CODE></LI>

        <LI>Precedence (low to high):

          <OL>
            <LI><CODE class="codelua">or</CODE></LI>

            <LI><CODE class="codelua">and</CODE></LI>

            <LI><CODE class="codelua">&lt; &gt; &lt;= &gt;= ~= ==</CODE></LI>

            <LI><CODE class="codelua">..</CODE> (string concatenation)</LI>

            <LI><CODE class="codelua">+ -</CODE></LI>

            <LI><CODE class="codelua">* / %</CODE></LI>

            <LI><CODE class="codelua">not # -</CODE> (unary)</LI>

            <LI><CODE class="codelua">^</CODE></LI>
          </OL>
        </LI>
      </UL>
    </LI>

    <LI>
      <B>Keywords</B>

      <UL>
        <LI><CODE class="codelua">and break do else elseif end false for
        function if in local nil not or repeat return then true until
        while</CODE></LI>
      </UL>
    </LI>

    <LI>
      <B>do ... end</B>

      <UL>
        <LI>Create a new local scope in a <CODE class="codelua">do ...
        end</CODE> block.</LI>

        <LI>Note : You cannot write <CODE class="codelua">function printHi()
        return; print("hi") end</CODE>, but you can have <CODE class=
        "codelua">function printHi() do return end; print("hi") end</CODE>
        which can be useful for debugging functions.</LI>
      </UL>
    </LI>
  </UL>

  <DIV class="codebox">
    <BLOCKQUOTE>
      <PRE>
do
    -- create a new local scope
    local a = 2
end
</PRE>
    </BLOCKQUOTE>
  </DIV>

  <UL>
    <LI><B>if (bool) then ... elseif (bool) then ... else ... end</B></LI>
  </UL>

  <DIV class="codebox">
    <BLOCKQUOTE>
      <PRE>
local a, b, c = 1, 2, 3 -- can assign multiple values
a = 1; b = 2; c = 3     -- use ; for multiple lines of code on single line
a, b, c = 1, 2, 3       -- this works too

if (a == 1) and ((b &lt;= 2) or (c ~= 3)) then
    print(a+b/c)
elseif a == 2 then      -- no parentheses necessary
    print(a)
else
    print(b)
end
</PRE>
    </BLOCKQUOTE>
  </DIV>

  <UL>
    <LI><B>There is no case statement</B>, but <CODE class=
    "codelua">table[value] = function() ... end</CODE> may be used to simulate
    one.</LI>
  </UL>

  <DIV class="codebox">
    <BLOCKQUOTE>
      <PRE>
case = {}
case[1] = function() print("Hello #1") end -- anonymous function
case[2] = function() print("Hello #2") end
...
if case[value] then
    case[value]()
else
    print("Unknown case value")
end
</PRE>
    </BLOCKQUOTE>
  </DIV>

  <UL>
    <LI>
      <B>while (bool) ... end</B>

      <UL>
        <LI>Note : there is no <CODE class="codelua">continue</CODE> keyword
        only <CODE class="codelua">break</CODE></LI>
      </UL>
    </LI>
  </UL>

  <DIV class="codebox">
    <BLOCKQUOTE>
      <PRE>
function Check5(val) -- returns nil if val ~= 5
    if val == 5 then
        return true
    end
end

local a = 1
while a &lt; 10 do
    print(a)
    if Check5(a) then break end
    a = a + 1 -- no increment operator
end
</PRE>
    </BLOCKQUOTE>
  </DIV>

  <DIV style="margin-left: 2em">
    <UL>
      <LI>You can simulate a <CODE class="codelua">continue</CODE> statement by
      adding an inner while loop (doesn't print # 5).</LI>
    </UL>
  </DIV>

  <DIV class="codebox">
    <BLOCKQUOTE>
      <PRE>
local a = 0
while a &lt; 10 do while true do
    a = a + 1 -- no increment operator
    if Check5 (a) then
        break -- break in the inner while loop to "continue" in the outer loop
    else
        print(a)
    end

    break end -- break out of inner while loop
end
</PRE>
    </BLOCKQUOTE>
  </DIV>

  <UL>
    <LI>
      <B>repeat ... until (bool)</B>

      <UL>
        <LI>Note : there is no <CODE class="codelua">continue</CODE> keyword
        only <CODE class="codelua">break</CODE></LI>
      </UL>
    </LI>
  </UL>

  <DIV class="codebox">
    <BLOCKQUOTE>
      <PRE>
local a = 10
repeat
    local temp = a * 2
    print(temp, type(temp))
    a = a - 1 -- no decrement operator
until a &lt; 0
</PRE>
    </BLOCKQUOTE>
  </DIV>

  <UL>
    <LI>
      <B>for var = init_value, end_value [, increment] do ... end</B>

      <UL>
        <LI>Note : there is no <CODE class="codelua">continue</CODE> keyword
        only <CODE class="codelua">break</CODE></LI>

        <LI>You cannot modify the loop variable, limit, or increment from
        within the loop.</LI>

        <LI>The loop counter variable is local to the loop and the final
        print(a) statement below will print that a = "hello" as it did before
        the loop.</LI>

        <LI>Copy the loop counter variable to a separate variable if you need
        to save it when breaking for example.</LI>
      </UL>
    </LI>
  </UL>

  <DIV class="codebox">
    <BLOCKQUOTE>
      <PRE>
local a = "hello"
for a = 1, 10 --[[, increment]] do -- optional increment value, default increment is 1
    local temp = a * 2
    print(temp)
end

print(a) -- a == "hello" since loop counter variable is local to the loop
</PRE>
    </BLOCKQUOTE>
  </DIV>

  <UL>
    <LI>
      <B>functions</B>

      <UL>
        <LI>Input any number of parameters by value, tables and userdata are
        passed by reference.</LI>

        <LI>Missing input variables are assigned the value <CODE class=
        "codelua">nil</CODE>, extra inputs are discarded.</LI>

        <LI>Return values using the "<CODE class="codelua">return</CODE>"
        keyword.</LI>

        <LI>Not all return values need to be used and extra ones will be
        discarded.

          <UL>
            <LI>The symbol "_" is a valid variable name and is often used as a
            dummy variable to receive return values that you do not want.

              <UL>
                <LI><CODE class="codelua">function GetNums() return 3, 4, 5, 6
                end; local _, num2 = GetNums()</CODE></LI>
              </UL>
            </LI>

            <LI>You may also use the <CODE class="codelua">select(n,
            ...)</CODE> function to choose return values to use.

              <UL>
                <LI><CODE class="codelua">print(select("#", GetNums()), "and",
                select(3, GetNums()))</CODE>, prints "4 and 5 6".</LI>

                <LI>Note <CODE class="codelua">select(n, ...)</CODE> returns
                all args after <CODE class="codelua">n</CODE>, but if the left
                hand side is a single variable the others are discarded.</LI>
              </UL>
            </LI>
          </UL>
        </LI>

        <LI>Tables can be used as containers for input values to functions
        using the <CODE class="codelua">unpack(table, [i, [, j]])</CODE>
        function.

          <UL>
            <LI>This is useful for creating complex inputs to a function or
            storing them for reuse.</LI>
          </UL>

          <UL>
            <LI><CODE class="codelua">print(string.find(unpack({"Hello", "ll",
            1, 1})))</CODE>, prints "3 4"</LI>
          </UL>
        </LI>

        <LI>Vararg inputs are written as <CODE class="codelua">function
        dostuff( ... ) end</CODE>

          <UL>
            <LI>The number of args is found using: <CODE class="codelua">local
            n_args = select("#", ...)</CODE></LI>

            <LI>The args can be converted into table using: <CODE class=
            "codelua">local args = { ... }</CODE></LI>

            <LI>A particular arg can be chosen using: <CODE class=
            "codelua">local arg3 = select(3, ...)</CODE>

              <UL>
                <LI>See above about using <CODE class="codelua">select()</CODE>
                to pick return values of a function as well.</LI>
              </UL>
            </LI>
          </UL>
        </LI>
      </UL>
    </LI>
  </UL>

  <DIV class="codebox">
    <BLOCKQUOTE>
      <PRE>
-- Print the keys in table t that have the values of in the table values
function PrintKeys(t, values, cmp_case)
    -- use nested functions for repetitive code or to simplify code
    local function cmp_values(a, b)
        if cmp_case then -- can use upvalue variables
            return a == b
        else
            return string.lower(a) == string.lower(b)
        end
    end
    local function find_key(t, val)
        for k,v in pairs(t) do
            if cmp_values(val, v) then return k end
        end
    end
    for i = 1, #vals do
        print(find_key(t, values[i]), values[i])
    end
end

-- prints "a1 a2", "b1 b2", "nil C2"
PrintKeys({a1 = "a2", b1 = "b2", c1 = "c2"}, {"a2", "b2", "C2"}, true)
</PRE>
    </BLOCKQUOTE>
  </DIV><BR>

  <DIV class="codebox">
    <BLOCKQUOTE>
      <PRE>
-- Varargs example; prints "4 4 4 20 20" and "table: 0183B820 10 30 5"
function Varargs(...)
    local args = {...}
    print(select("#", ...), #{...}, #args, args[2], unpack({...}, 2, 2))
    return args, unpack(args) -- same as return ...
end

vals, val1, _, val3 = Varargs(10, 20, 30, 40)
print(vals, val1, val3, select("#", Varargs(10, 20, 30, 40)))
</PRE>
    </BLOCKQUOTE>
  </DIV>

  <H2><A name="C4" id="C4"></A>4 - Bit Library</H2>wxLua automatically loads a
  library for manipulating the bits of an integer and puts it into the global
  <CODE class="codelua">bit</CODE> table. This is because wxWidgets often uses
  enumeration flags to control the behavior of functions and for compactly
  storing status information. You can easily "or" bits by adding them together
  and this is the preferred method, for example 0x02 + 0x04 = 0x06 or bitwise
  0110. If the bits you're trying to "or" are not powers of 2 (perhaps one is a
  bit mask) this fails, 0x01 + 0x03 = 0x04 or bitwise 0100 (oops) instead of
  the desired 0011.<BR>
  <BR>
  wxLua uses the bitlib library written by Reuben Thomas and since the code for
  it is very small, it's embedded into the wxLua sourcecode.<BR>
  <BR>
  All function arguments should be integers. The number of bits available for
  logical operations depends on the data type used to represent Lua numbers;
  this is typically 8-byte IEEE floats, which give 53 bits (the size of the
  mantissa).<BR>
  The logical operations start with "b" for "bit" to avoid clashing with
  reserved words; although "xor" isn't a reserved word, it seemed better to use
  "bxor" for consistency.<BR>

  <UL>
    <LI>bit.bnot(a) returns the one's complement of a</LI>

    <LI>bit.band(w1,...) returns the bitwise and of the w's</LI>

    <LI>bit.bor(w1,...) returns the bitwise or of the w's</LI>

    <LI>bit.bxor(w1,...) returns the bitwise exclusive or of the w's</LI>

    <LI>bit.lshift(a,b) returns a shifted left b places</LI>

    <LI>bit.rshift(a,b) returns a shifted logically right b places</LI>

    <LI>bit.arshift(a,b) returns a shifted arithmetically right b places (works
    on negative numbers too)</LI>

    <LI>bit.mod(a,b) returns the integer remainder of a divided by b</LI>
  </UL>

  <H2><A name="C5" id="C5"></A>5 - Programming in wxLua</H2>Programming in
  wxLua means that you're writing programs in the Lua language using an
  additional table of functions, objects, numbers, strings, and "classes" in
  the namespace table <CODE class="codelua">wx</CODE> from wxWidgets.
  Additional libraries may be added as bindings and can be placed in their own
  "namespace" table, but for the examples below we will use the <CODE class=
  "codelua">wx</CODE> table.<BR>
  <BR>
  The list below are the tables that wxLua creates containing the binding
  functions or objects. These are in addition to the standard Lua tables;
  <B>coroutine, debug, io, math, os, package, string, table</B>. Note that the
  wxaui and wxstc libraries have been separated into their own tables since
  they are fairly specialized libraries.<BR>

  <UL>
    <LI><B>bit</B> - The bit library from Reuben Thomas for manipulating
    integer bits.</LI>

    <LI><B>wxlua</B> - Special functions for introspecting into wxLua or
    generic functions that wxLua provides that are independent of
    wxWidgets.</LI>

    <LI><B>wx</B> - wxWidgets functions, classes, defines, enums, strings,
    events, and objects are placed here.</LI>

    <LI><B>wxaui</B> - The wxWidgets Advanced User Interface library.</LI>

    <LI><B>wxstc</B> - The wxStyledTextCtrl wrapper around the Scintilla text
    editor.</LI>
  </UL>The semantics for accessing wxWidgets elements in wxLua tries to map as
  closely as possible to the underlying C++ notation so that the official C++
  documentation may be used as a reference, <A href=
  "http://www.wxwidgets.org/docs">http://www.wxwidgets.org/docs</A>. The most
  common case where wxLua deviates from C++ are for functionss with values
  passed by reference to be changed; wxLua will return multiple values instead.
  Please see the <A href="wxluaref.html">wxluaref.html</A> document that lists
  all the wxWidgets objects wrapped by wxLua and take note of the functions
  that are marked <I>%override</I> since you will need to use them as described
  in that document. You should also look at the <A href=
  "binding.html">binding.html</A> file, even if you do not plan to write your
  own bindings, to get a better understanding of the <A href=
  "wxluaref.html">wxluaref.html</A> file.<BR>
  <BR>
  <U><B>Strings</B></U>: wxLua does not typically use the wxString class for
  strings, rather it uses Lua strings. This means that all wxWidgets functions
  that take a wxString parameter take either a wxString userdata or preferrably
  a Lua string (Lua variables that are of type(var) == "string"). Functions
  that return wxStrings convert the value into a Lua string for convenience.
  The conversion from the Lua ANSI C 8-bit char* string to a wxString (which
  may be a Unicode wchar* string) is done internally.<BR>
  <BR>
  <U><B>wxArrayString and wxSortedArrayString:</B></U> Function parameters that
  take a "const wxArrayString&amp; arr" or "wxArrayString arr" will accept
  either a wxArrayString userdata or a Lua table that has numeric indexes and
  string values and convert it into a wxArrayString for the function call. If
  the function call is "wxArrayString&amp; arr" or "wxArrayString* arr" you
  must provide a wxArrayString userdata since the C++ function will most likely
  modify the wxArrayString that's passed to it.<BR>
  <BR>
  <U><B>wxArrayInt</B></U>: Function parameters that take a "const
  wxArrayInt&amp; arr" or "wxArrayInt arr" will accept either a wxArrayInt
  userdata or a Lua table that has numeric indexes and numeric values and
  convert it into a wxArrayInt for the function call. If the function call is
  "wxArrayInt&amp; arr" or "wxArrayInt* arr" you must provide a wxArrayInt
  userdata since the C++ function will most likely modify the wxArrayInt that's
  passed to it.<BR>

  <H3><A name="C5.1" id="C5.1"></A>5.1 - Naming, location, and usage of the
  wxWidgets objects declared in the C++ header files in the <CODE class=
  "codelua">wx</CODE> Lua table</H3>

  <UL>
    <LI>
      <B>#define NUMBER_DEFINE VALUE</B>

      <UL>
        <LI>All #defined numerical values are available as <CODE class=
        "codelua">wx.NUMBER_DEFINE</CODE></LI>

        <LI>Example <I>"#define wxID_ANY -1"</I> is accessed as <CODE class=
        "codelua">wx.wxID_ANY</CODE></LI>

        <LI>Declared in the bindings using the <I>%define</I> tag</LI>
      </UL>
    </LI>

    <LI>
      <B>[int, double, etc] NUMBER_VARIABLE;</B>

      <UL>
        <LI>All global numerical variables are available as <CODE class=
        "codelua">wx.NUMBER_VARIABLE</CODE></LI>

        <LI>Example : <I>"extern const int wxInvalidOffset;"</I> is accessible
        as <CODE class="codelua">wx.wxInvalidOffset</CODE>.</LI>

        <LI>Declared in the bindings using the <I>%define</I> tag</LI>
      </UL>
    </LI>

    <LI>
      <B>enum ENUM_NAMESPACE [or CLASSNAME::ENUM_NAMESPACE] { ENUM_NAME }</B>

      <UL>
        <LI>All global enums, named or not, are available as <CODE class=
        "codelua">wx.ENUM_NAME</CODE>

          <UL>
            <LI>Example : <I>"enum wxDirection { wxLEFT, ... }"</I> is
            accessible as <CODE class="codelua">wx.wxLEFT</CODE></LI>
          </UL>
        </LI>

        <LI>All enums that are members of classes are available as
          <CODE class="codelua">wx.CLASSNAME.ENUM_NAME</CODE>

          <UL>
            <LI>Example : <I>"enum wxFTP::TransferMode { ASCII, ... }"</I> is
            accessible as <CODE class="codelua">wx.wxFTP.ASCII</CODE></LI>
          </UL>
        </LI>

        <LI>This follows the C++ semantics that you do not specify the name of
        an enum, but you do have to use its scope if it is a class member.</LI>

        <LI>Declared in the bindings using the <I>%enum</I> tag</LI>
      </UL>
    </LI>

    <LI>
      <B>#define STRING_DEFINE wxT("String Value")</B>

      <UL>
        <LI>All #defined string values are available as <CODE class=
        "codelua">wx.STRING_DEFINE</CODE></LI>

        <LI>Example : <I>"#define wxIMAGE_OPTION_CUR_HOTSPOT_X
        wxT("HotSpotX")"</I> is accessible as <CODE class=
        "codelua">wx.wxIMAGE_OPTION_CUR_HOTSPOT_X</CODE></LI>

        <LI>Declared in the bindings using the <I>%define_string</I> tag</LI>
      </UL>
    </LI>

    <LI>
      <B>const wxChar* STRING_VARIABLE;</B>

      <UL>
        <LI>All global string variables are available as <CODE class=
        "codelua">wx.STRING_VARIABLE</CODE></LI>

        <LI>No examples yet.</LI>

        <LI>Declared in the bindings using the <I>%define_string</I> tag</LI>
      </UL>
    </LI>

    <LI>
      <B>wxEVT_XXX for wxEvtHandler::Connect()</B>

      <UL>
        <LI>All <I>wxEVT_XXX</I> wxEventTypes (an integer) are available as
        <CODE class="codelua">wx.wxEVT_XXX</CODE>

          <UL>
            <LI>Example : <CODE class=
            "codelua">wx.wxEVT_COMMAND_MENU_SELECTED</CODE> for menu item
            selection.</LI>
          </UL>
        </LI>

        <LI>wxLua does not use the static event tables, the EVT_XXX() macros,
        since it is not a compiled language, but rather the corresponding
        wxEVT_XXX. The <A href="wxluaref.html">wxluaref.html</A> manual
        contains a complete mapping between the two.</LI>

        <LI>Use the wxEvtHandler::Connect() function to connect event types to
        a wxEvtHandler; typically a wxWindow derived class.

          <UL>
            <LI>Example : <I>EVT_MENU(id, func)</I> use <CODE class=
            "codelua">window:Connect(menuId, wx.wxEVT_COMMAND_MENU_SELECTED,
            Lua function)</CODE>. The Lua function must have the signature of
            <CODE class="codelua">function MenuEvent(event) ... handle event
            ... return</CODE> where the event variable will be of the wxEvent
            class the wxEventType was declared in, which in this case is a
            wxCommandEvent.</LI>
          </UL>

          <UL>
            <LI>Example : <I>EVT_PAINT(func)</I> use <CODE class=
            "codelua">window:Connect(wx.wxEVT_PAINT, Lua function)</CODE>.
            There is no id used for this connect event function call since you
            are directly connecting the paint event to the window, whereas in
            the menu case you are handling a menu event from the menu that
            travels up the chain of window parents until a handler is found,
            therefore you need the Id to determine where the event came from.

              <UL style="color: red;">
                <LI>Note: You must always create a wxPaintDC for wxEVT_PAINT to
                clear the update region.</LI>
              </UL>

              <UL>
                <LI><CODE class="codelua">local dc =
                wx.wxPaintDC(event:GetEventObject():DynamicCast("wxWindow"))</CODE>
                and then call <CODE class="codelua">dc:delete()</CODE> at the
                end of the function because the paint event clears the "dirty"
                region to repaint and if it is not cleared another paint event
                will be sent... and so on.</LI>
              </UL>
            </LI>
          </UL>
        </LI>

        <LI>Declared in the bindings using the <I>%define_event</I> tag</LI>
      </UL>
    </LI>

    <LI>
      <B>Objects of classes or structs OBJECT_NAME</B>

      <UL>
        <LI>All global objects that are classes or structs are available as
        <CODE class="codelua">wx.OBJECT_NAME</CODE></LI>

        <LI>Example : <I>"const wxImage wxNullImage;"</I> is accessible as
        <CODE class="codelua">wx.wxNullImage</CODE> and functions from the
        wxImage class can be called as <CODE class=
        "codelua">wx.wxNullImage:Ok()</CODE> which should return false.</LI>

        <LI>Declared in the bindings using the <I>%define_object</I> tag</LI>
      </UL>
    </LI>

    <LI>
      <B>Pointers to classes or structs POINTER_NAME</B>

      <UL>
        <LI>All global pointers that are classes or structs are available as
        <CODE class="codelua">wx.POINTER_NAME</CODE></LI>

        <LI>Example : <I>"extern wxPenList* wxThePenList;"</I> is accessible as
        <CODE class="codelua">wx.wxThePenList</CODE> and functions from the
        wxPenList class can be made as <CODE class="codelua">pen =
        wx.wxThePenList:FindOrCreatePen(wx.wxColour(1,2,3), 1,
        wx.wxSOLID)</CODE></LI>

        <LI>Declared in the bindings using the <I>%define_object</I> tag</LI>
      </UL>
    </LI>

    <LI>
      <B>Global C style functions VAR_TYPE FUNCTION_NAME(int a, const
      wxString&amp; str)</B>

      <UL>
        <LI>All global C style functions are available as <CODE class=
        "codelua">wx.FUNCTION_NAME(1, "Hello")</CODE></LI>

        <LI>Example : "<CODE class="codelua">extern wxString
        wxGetUserHome(const wxString&amp; name)"</CODE> is accessible as
        "<CODE class="codelua">home_dir = wx.wxGetUserHome("john")</CODE>"
        where wxString means to input a Lua string and a Lua string is
        returned.</LI>

        <LI>Declared in the bindings using the <I>%function</I> tag</LI>
      </UL>
    </LI>

    <LI>
      <B>C++ Classes CLASS_NAME</B>

      <UL>
        <LI>All C++ classes are available as <CODE class=
        "codelua">wx.CLASS_NAME</CODE>, however in order to use one you must
        call one of the constructors first or get the class as a return value
        from another function call.

          <UL>
            <LI>Example : "<CODE class="codelua">pt = wx.wxPoint(1, 2); pt2 =
            wx.wxPoint(pt)</CODE>".</LI>

            <LI>Multiple member functions with the same name are overloaded as
            in C++ and the proper function to call is determined at runtime.
            This is one of the reasons why wxLua is stricter about type than
            Lua. For example; string arguments do not accept numbers which Lua
            would silently convert.</LI>

            <LI>Member functions inherited from the base class(es) are also
            available and may be overloaded as well.</LI>

            <LI>The C++ classes are exposed as tables in Lua, but have a
            <CODE class="codelua">__call</CODE> metatable item so they can be
            called as a function. If you need to get the constructor function
            itself you can use <CODE class=
            "codelua">wx.CLASS_NAME.new(...)</CODE> which is the constructor
            exposed as a Cfunction.</LI>
          </UL>
        </LI>

        <LI>The C++ class objects are pushed into Lua as a userdata wrapping a
        void* pointer to the C++ object.

          <UL>
            <LI>A special metatable is set on the userdata with these entries :

              <UL>
                <LI><CODE class="codelua">__index</CODE> to call functions on
                the object or to get member variable values.</LI>

                <LI><CODE class="codelua">__newindex</CODE> to set new
                functions or values or set member variable values.</LI>

                <LI>
                  <CODE class="codelua">__tostring</CODE> to allow print() to
                  show something useful

                  <UL>
                    <LI><CODE class="codelua">print(wx.wxPoint())</CODE> prints
                    "userdata: 0x858df5c [wxPoint(0x84ab550, 251)]", where
                    0x858df5c is the Lua userdata address, 0x84ab550 is the
                    address of the wxPoint object, and 251 is the wxLua type
                    that wxLua uses to determine that this Lua userdata wraps a
                    wxPoint. The wxPoint type may not always be 251 since it
                    depends on the number and order in which the bindings were
                    initialized.</LI>
                  </UL>
                </LI>

                <LI><CODE class="codelua">__gc</CODE> to tell wxLua when the
                userdata is no longer used so wxLua can delete the C++ object
                if appropriate.</LI>
              </UL>
            </LI>
          </UL>
        </LI>

        <LI>Declared in the bindings using the <I>%class</I> tag</LI>

        <LI>
          <B>Deleting class userdata</B> can be done using the wxLua added
          class member function delete().

          <UL>
            <LI>All classes that have the %delete binding tag will be
            eventually garbage collected when they go out of scope.</LI>

            <LI>Classes without the %delete tag are assumed to be eventually
            attached to another object that will delete them for you.</LI>

            <LI>The Lua garbage collector uses an incremental collector that
            waits until the data size reaches a limit and slowly removes them
            to avoid program slowdown. This is a good thing and makes Lua
            programs run at an even pace.</LI>

            <LI>However! Some graphical device interface (GDI) classes need to
            be deleted immediately after you are done using them.

              <UL>
                <LI>This is really a problem only in MS Windows. Windows 95
                based systems are allowed only dozens of GDI objects at any one
                time, but even in NT systems (XP, Vista) you will have problems
                if you've created hundreds of them. One visible sign that
                something is wrong is when controls, like menus, stop redrawing
                themselves properly and the program becomes sluggish.</LI>

                <LI>In any case, just delete() them when done so that your
                program will work equally well in MSW as it would in Linux or
                OSX.</LI>
              </UL>
            </LI>

            <LI>Additionally, since the Lua userdata that wxLua pushes into Lua
            only store a void* pointer to the C++ class object, Lua only thinks
            they are of size void* which are only 8 bytes on 64bit x86
            machines. However, the class might store a 1024x768 x 3 bytes/pixel
            image as a wxImage (2.36Mb). There have been a number of
            discussions about this on the Lua mailing list, but currently there
            is no way to let Lua know the true size of a userdata to help it
            better decide when and what to garbage collect. The core of Lua
            could be modified, but that would make it harder to use wxLua as a
            loadable module.</LI>

            <LI>The solution is to use the delete() function on certain types
            of userdata when you are done.</LI>

            <LI>
              <FONT color="red">Care must be taken to ensure that you're not
              silently creating too many temporary objects.</FONT>

              <UL>
                <LI>Example: <CODE class=
                "codelua">wxDC:SetPen(wx.wxPen(wx.wxColour(1,2,3), 1,
                wx.wxSOLID))</CODE>; notice that both a wxPen and a wxColour
                have been created, but there is no way for you to call delete()
                on them so they will collect until Lua runs its garbage
                collector.</LI>

                <LI>You can force garbage collection using <CODE class=
                "codelua">collectgarbage("collect")</CODE> in Lua, but this may
                cause pauses in your program's execution.</LI>

                <LI>It is a good idea to collect all the garbage at the end of
                your initialization function to at least start out with a clean
                slate since program startup time is usually not a concern.</LI>
              </UL>
            </LI>

            <LI>
              <FONT color="red">This is a list of classes by order of
              importance of deleting them</FONT>

              <UL>
                <LI style="font-weight: bold;"><FONT color="red">Must delete :
                wxDC, wxPaintDC, and ALL classed derived from wxDC</FONT></LI>

                <LI>
                  <FONT color="red"><B>Must delete if &gt; 50 : wxBitmap,
                  wxBrush, wxColour, wxCursor, wxFont, wxIcon, wxPen,
                  wxRegion</B></FONT>

                  <UL>
                    <LI><FONT color="red">To be sure, delete them when you're
                    done and not worry.</FONT></LI>
                  </UL>
                </LI>

                <LI><FONT color="red">Must delete if large and you're creating
                many of them : wxImage</FONT></LI>

                <LI><FONT color="red">Don't bother : wxPoint, wxRect...
                etc</FONT></LI>

                <LI>
                  <FONT color="red">Never delete : wxWindows attached their
                  their parents (use Destroy()), wxMenuItems returned from a
                  wxMenu.</FONT>

                  <UL>
                    <LI><FONT color="red">Safe rule, don't delete() things that
                    aren't yours. Refer to the wxWidgets documentation about
                    whether an object will take ownership of an object passed
                    to it.</FONT></LI>
                  </UL>
                </LI>
              </UL>
            </LI>

            <LI>How to tell how many userdata objects you currently have?

              <UL>
                <LI>Print the output of <CODE class=
                "codelua">wxlua.GetGCUserdataInfo(true)</CODE> to show what
                objects will be garbage collected when their reference count
                goes to 0 and the Lua garbage collector runs.</LI>

                <LI>Print the output of <CODE class=
                "codelua">wxlua.GetTrackedObjectInfo(true)</CODE> to get class
                objects that wxLua has pushed into Lua that may or may not be
                garbage collected.</LI>
              </UL>

              <UL>
                <LI>Call the function <CODE class=
                "codelua">wxlua.LuaStackDialog()</CODE> when you run your
                program and examine the items in the Lua LUA_REGISTRYINDEX
                table. Expand "wxLua objects pushed" and "wxLua gc objects to
                delete" tables.</LI>
              </UL>
            </LI>
          </UL>
        </LI>

        <LI>
          <B>Member functions</B> of the class are called using the colon ':'
          convention and NOT the period '.'. This is because ':' in Lua puts
          the object itself on the stack, the "self" as it's called, and this
          is used by the binding code to call the function with. If you
          <I>really</I> want to use the '.' notation you can pass the "self" in
          as the first parameter. There are two exceptions to the ':' calling
          convention rule, <B>properties</B> and <B>static</B> functions,
          please see the sections below about why they only use the '.'
          convention.

          <UL>
            <LI>Example : "<CODE class="codelua">size = wx.wxSize(1, 2);
            size:SetWidth(10); size.SetHeight(size, 11); print(size:GetWidth(),
            size.GetHeight(size))</CODE>" where we create a wxSize, set a new
            width and height, and then print the numerical values.</LI>

            <LI>Functions may be renamed in the bindings using the
            <I>%rename</I> tag in the interface files. You call the functions
            using the name after the <I>%rename</I> tag with the same
            parameters as the original function. This is only done for special
            cases that would be awkward, if not impossible, to wrap
            otherwise.</LI>
          </UL>
        </LI>

        <LI>
          <B>Property functions</B> allow you to read and/or write values to a
          class using the '.' convention and a shortened name.

          <UL>
            <LI>These are generated on the fly when the function is called on a
            wxLua userdata and work only for functions following these rules.

              <UL>
                <LI>GetXXX() takes no values and returns one.</LI>

                <LI>SetXXX(value) takes one value and returns none.</LI>
              </UL>
            </LI>

            <LI>The Get/Set part of the function name is removed leaving only
            XXX and you do not call them like a function using "()", but rather
            like accessing a table member, without the "()".</LI>

            <LI>Example : "<CODE class="codelua">rect =
            wx.wxRect(wx.wxPoint(1,2), wx.wxSize(3,4)); rect:SetX(20); rect.X =
            10; print(rect.X, rect.X == rect:GetX(), rect.X ==
            rect.GetX(rect))</CODE>" should print "10, true, true".</LI>

            <LI>Note : There is no way to find out from Lua if the code used a
            '.' or a ':' to call the function and therefore properties cannot
            be made to work for the ':' calling convention since in that case
            we have to remove the object (the self) that Lua automatically
            pushes onto the stack that we don't need or want.</LI>

            <LI>Note : Since these methods are generated at runtime they will
            not work for static functions in the class table, but they will
            work for static functions called from a userdata object.</LI>

            <LI>Below is a list of what works and doesn't, the example is for a
            static function, but the same works for a regular class member
            function.

              <UL>
                <LI>Works (static functions only) : <CODE class=
                "codelua">print(wx.wxFileName.GetCwd())</CODE> and <CODE class=
                "codelua">print(wx.wxFileName.GetCwd)</CODE> prints that it's a
                function.</LI>

                <LI>Fails (static functions only) : <CODE class=
                "codelua">print(wx.wxFileName:GetCwd())</CODE> and <CODE class=
                "codelua">print(wx.wxFileName:GetCwd)</CODE></LI>

                <LI>Works : <CODE class="codelua">f = wx.wxFileName("a");
                print(f.GetCwd())</CODE> and <CODE class=
                "codelua">print(f.GetCwd)</CODE> prints that it's a
                function.</LI>

                <LI>Fails : <CODE class="codelua">f = wx.wxFileName("a");
                print(f:GetCwd())</CODE> and <CODE class=
                "codelua">print(f:GetCwd)</CODE></LI>

                <LI>Works : <CODE class="codelua">f = wx.wxFileName("a");
                print(f.Cwd)</CODE></LI>

                <LI>Fails : <CODE class="codelua">f = wx.wxFileName("a");
                print(f.Cwd())</CODE> and <CODE class=
                "codelua">print(f:Cwd)</CODE> and <CODE class=
                "codelua">print(f:Cwd())</CODE></LI>
              </UL>
            </LI>

            <LI>Note : Are properties really necessary? Confusing? Useful? I'd
            stick with the Get/Set functions. - JL</LI>
          </UL>
        </LI>

        <LI>
          <B>Member variables</B> allow you to read and/or write to member
          variables of a class.

          <UL>
            <LI>Declared in the interface files using the <I>%member</I> or
            <I>%member_func</I> tag.</LI>

            <LI>Example : In the interface file <I>gdi.i</I> this is declared
            for wxPoint : <I>"%rename X %member_func int x"</I></LI>

            <LI>The wxPoint class does not have functions to access the int x,
            y variables so we create our own.</LI>

            <LI>The <I>%member_func</I> tag creates functions called
            Get/Set[variable name] or in this case Getx() and Setx(value), but
            these aren't too pretty so we use the <I>%rename</I> tag to rename
            them to GetX() and SetX(value). It additionally creates properties
            for the x variable so the '.' calling convention also works.</LI>

            <LI>These two methods of getting and setting the x and y member of
            the wxPoint class are interchangeable.

              <UL>
                <LI>Example : <CODE class="codelua">pt = wx.wxPoint(1,2); pt.x
                = 10; pt:SetY(11); print(pt.x, pt:GetY())</CODE></LI>
              </UL>
            </LI>

            <LI>If the <I>%member</I> tag is used (as opposed to the
            <I>%member_func</I>) the Get/Set functions are not generated and
            the member variables are accessible only through the
            properties.</LI>

            <LI>If the member variable is constant (const) the variable is
            read-only and you cannot set its value.</LI>
          </UL>
        </LI>

        <LI>
          <B>Static functions</B> are part of the table that holds the class
          and can be called with or without a class instance (a userdata).

          <UL>
            <LI>Example : <CODE class="codelua">f = wx.wxFileName('dummy');
            f.GetCwd() == wx.wxFileName.GetCwd()</CODE></LI>

            <LI>Note that you always use the '.' calling convention since
            static C++ functions do not require the object itself or in Lua's
            case the userdata.</LI>

            <LI>See the <B>properties</B> section about the difference between
            '.' and ':' and why using a ':' cannot be made to work reliably
            when you don't want or need the self pushed onto the stack.</LI>
          </UL>
        </LI>

        <LI>
          <B>Enum members</B> are also part of the table that holds the class
          and are used by accessing the class table itself.

          <UL>
            <LI>Example : <I>"enum wxFTP::TransferMode { ASCII, ... }"</I> is
            accessible as <CODE class="codelua">wx.wxFTP.ASCII</CODE></LI>
          </UL>
        </LI>

        <LI>
          <B>Operator functions</B> allow you to use C++ operators in Lua.

          <UL>
            <LI>Lua has a limited set of operators, see the Lua primer, whereas
            C++ can define many more. Also, not all C++ operators are defined
            for all classes and very few classes can be mixed with other
            classes. Operators for classes must be declared in C++. Therefore
            Lua uses functions to call these operators rather than try to
            directly modify the existing ones in Lua and then declare the
            remaining ones as functions.</LI>

            <LI>Note also that declaring every operator for all classes in
            wxLua is usually not necessary because in C++ they typically shadow
            an existing function that wxLua already wraps.</LI>

            <LI>The Lua = operator for a class object will merely create a
            reference to the object and this itself is useful and why wxLua
            does not try to override the default behavior.</LI>

            <LI>Declared in the interface files using the <I>%operator</I>
            tag.</LI>

            <LI>This is a list of all possible operator functions:

              <TABLE border="0" summary="">
                <TR>
                  <TD colspan="2" style="color: #336699">Relational and
                  equality operators</TD>
                </TR>

                <TR>
                  <TD>==</TD>

                  <TD>op_eq()</TD>
                </TR>

                <TR>
                  <TD>!=</TD>

                  <TD>op_ne()</TD>
                </TR>

                <TR>
                  <TD>&gt;</TD>

                  <TD>op_gt()</TD>
                </TR>

                <TR>
                  <TD>&lt;</TD>

                  <TD>op_lt()</TD>
                </TR>

                <TR>
                  <TD>&gt;=</TD>

                  <TD>op_ge()</TD>
                </TR>

                <TR>
                  <TD>&lt;=</TD>

                  <TD>op_le()</TD>
                </TR>

                <TR>
                  <TD colspan="2" style="color: #336699">Logical operators</TD>
                </TR>

                <TR>
                  <TD>!</TD>

                  <TD>op_not()</TD>
                </TR>

                <TR>
                  <TD>&amp;&amp;</TD>

                  <TD>op_land()</TD>

                  <TD>"l" stands for logical</TD>
                </TR>

                <TR>
                  <TD>||</TD>

                  <TD>op_lor()</TD>
                </TR>

                <TR>
                  <TD colspan="2" style="color: #336699">Bitwise operators</TD>
                </TR>

                <TR>
                  <TD>~</TD>

                  <TD>op_comp()</TD>

                  <TD>bitwise NOT or complement</TD>
                </TR>

                <TR>
                  <TD>&amp;</TD>

                  <TD>op_and()</TD>
                </TR>

                <TR>
                  <TD>|</TD>

                  <TD>op_or()</TD>
                </TR>

                <TR>
                  <TD>^</TD>

                  <TD>op_xor()</TD>
                </TR>

                <TR>
                  <TD>&lt;&lt;</TD>

                  <TD>op_lshift()</TD>
                </TR>

                <TR>
                  <TD>&gt;&gt;</TD>

                  <TD>op_rshift()</TD>
                </TR>

                <TR>
                  <TD colspan="2" style="color: #336699">Inplace bitwise
                  assignment operators</TD>
                </TR>

                <TR>
                  <TD>&amp;=</TD>

                  <TD>op_iand()</TD>

                  <TD>"i" stands for inplace</TD>
                </TR>

                <TR>
                  <TD>|=</TD>

                  <TD>op_ior()</TD>
                </TR>

                <TR>
                  <TD>^=</TD>

                  <TD>op_ixor()</TD>
                </TR>

                <TR>
                  <TD>&gt;&gt;=</TD>

                  <TD>op_irshift()</TD>
                </TR>

                <TR>
                  <TD>&lt;&lt;=</TD>

                  <TD>op_ilshift()</TD>
                </TR>

                <TR>
                  <TD colspan="2" style="color: #336699">Arithmetic
                  operators</TD>
                </TR>

                <TR>
                  <TD>=</TD>

                  <TD>op_set()</TD>
                </TR>

                <TR>
                  <TD>+</TD>

                  <TD>op_add()</TD>
                </TR>

                <TR>
                  <TD>-</TD>

                  <TD>op_sub()</TD>
                </TR>

                <TR>
                  <TD>*</TD>

                  <TD>op_mul()</TD>
                </TR>

                <TR>
                  <TD>/</TD>

                  <TD>op_div()</TD>
                </TR>

                <TR>
                  <TD>%</TD>

                  <TD>op_mod()</TD>
                </TR>

                <TR>
                  <TD colspan="2" style="color: #336699">Unary arithmetic
                  operators</TD>
                </TR>

                <TR>
                  <TD>-</TD>

                  <TD>op_neg()</TD>

                  <TD>negate</TD>
                </TR>

                <TR>
                  <TD colspan="2" style="color: #336699">Inplace arithmetic
                  assignment operators</TD>
                </TR>

                <TR>
                  <TD>+=</TD>

                  <TD>op_iadd()</TD>
                </TR>

                <TR>
                  <TD>-=</TD>

                  <TD>op_isub()</TD>
                </TR>

                <TR>
                  <TD>*=</TD>

                  <TD>op_imul()</TD>
                </TR>

                <TR>
                  <TD>/=</TD>

                  <TD>op_idiv()</TD>
                </TR>

                <TR>
                  <TD>%=</TD>

                  <TD>op_imod()</TD>
                </TR>

                <TR>
                  <TD colspan="2" style="color: #336699">Increment arithmetic
                  operators</TD>
                </TR>

                <TR>
                  <TD>++</TD>

                  <TD>op_inc()</TD>
                </TR>

                <TR>
                  <TD>--</TD>

                  <TD>op_dec()</TD>
                </TR>

                <TR>
                  <TD colspan="2" style="color: #336699">Other operators</TD>
                </TR>

                <TR>
                  <TD>[]</TD>

                  <TD>op_index()</TD>

                  <TD>Array indexing</TD>
                </TR>

                <TR>
                  <TD>()</TD>

                  <TD>op_func()</TD>

                  <TD>Function call</TD>
                </TR>
              </TABLE>
            </LI>

            <LI>Example : <CODE class="codelua">pt = wx.wxPoint(1,2); pt = pt +
            1</CODE> gives an error since we're trying to use the Lua operator
            and even in C++ this wouldn't compile since there is no operator
            defined for adding a single number to a wxPoint.</LI>

            <LI>Example : <CODE class="codelua">pt1 = wx.wxPoint(1,2); pt2 =
            pt1; print(pt2:GetX()); pt2:SetX(10); print(pt1:GetX(), pt1 ==
            pt2)</CODE> the = operator works in this case because we are not
            copying the values of pt1, but rather the address of pt1 to pt2,
            meaning that pt2 <B><I>is</I></B> pt1 and when we set the value for
            pt2 we're also setting the value for pt1. We know this because the
            Lua == operators tells us that they have the same address and if
            you type <CODE class="codelua">print(pt1, pt2)</CODE> the result is
            <I>"userdata: 0x858df5c [wxPoint(0x84ab550, 251)], userdata:
            0x858df5c [wxPoint(0x84ab550, 251)]"</I>. See the wxLua userdata
            metatable function <CODE class="codelua">__tostring</CODE>
            above.</LI>

            <LI>Example : <CODE class="codelua">pt1 = wx.wxPoint(1,2); pt2 =
            wx.wxPoint(); pt2:op_set(pt1); pt1:SetX(10); print(pt2:GetX());
            print(pt2:op_eq(pt1))</CODE> creates pt1 and also creates pt2, but
            we don't care what value it has since we use op_set to use the C++
            = operator to copy the values from pt1. We then change the value of
            pt1, test if pt2 has changed, it hasn't, and the test to see if
            they're still equal and as expected, they're not.</LI>
          </UL>
        </LI>

        <LI style="font-weight: bold;">Virtual functions

          <UL>
            <LI>You cannot arbitrarily override C++ virtual functions in wxLua
            as this must be done in C++. The C++ class must be subclassed and
            the virtual functions overridden to check to see if there is a Lua
            function to call instead of the base class function. This has only
            been done for cases where it is necessary. In many cases you can
            intercept the appropriate wxEvent and change the behavior from
            within the handler.</LI>

            <LI>Examples of virtual functions that must or can be overridden
            are in the wxLuaPrintout class, see the printing sample, and
            wxLuaHtmlWindow, see html sample. The only virtual functions that
            you can override are marked with comments in the binding files and
            wxluaref.htm.</LI>

            <LI>Prepend the function name with an underscore, '_' in order to
            directly access the C++ base class function that you have
            overridden in Lua.</LI>

            <LI>Adding virtual functions to wxLua will be done on a case by
            case basis. If it is absolutely necessary to override a virtual
            function for a class you should ask about adding it on the wxLua
            mailing list. The reason why they have not already been added is
            that there is a price to pay in terms of binding size and
            speed.</LI>
          </UL>
        </LI>

        <LI>
          <B>Overriding member functions</B> with Lua functions

          <UL>
            <LI>You may override class member functions for a wxLua userdata
            and still be able to call back to the Cfunction by prepending the
            function name with an underscore '_'.</LI>

            <LI>The Lua function that you assign to a userdata will be called
            directly from Lua without regard to the existing Cfunction(s), but
            will never be called by the C++ class functions.</LI>

            <LI>Example : <CODE class="codelua">p = wx.wxPoint(1,2); p.GetX =
            function(self) return 10-self:_GetX() end; print(p:GetX(),
            p:_GetX())</CODE> prints "9, 1".</LI>

            <LI>Note : Make sure that if you want to call the base function you
            use the '_' in your overridden function since otherwise you'll get
            recursion.</LI>
          </UL>
        </LI>

        <LI>
          <B>Extending classes</B>

          <UL>
            <LI>You may add your own functions to classes that will not be
            called by C++, but can be called from Lua. This makes sense if you
            would like to keep functions that act on a particular class with it
            rather than having global functions that take that class as a
            parameter.</LI>

            <LI>Example : <CODE class="codelua">r = wx.wxRect(1,2,3,4);
            r.PrintXY = function(self) print(self:GetX(), self:GetY()) end;
            r:PrintXY()</CODE> adds the function PrintXY() to the wxRect
            instance r. The userdata, class instance, r is passed to the Lua
            function as the parameter "self" which is pushed onto the stack
            when the PrintXY() function is called with the ":" notation.</LI>

            <LI>Note that the above example is the same as <CODE class=
            "codelua">r = wx.wxRect(1,2,3,4); function wxRect_PrintXY(r)
            print(r:GetX(), r:GetY()) end; wxRect_PrintXY(r)</CODE>.</LI>

            <LI>You may also create the Lua function beforehand and then assign
            it to the rect object. <CODE class="codelua">function
            wxRect_PrintXY_func(self) print(self:GetX(), self:GetY()) end; r1 =
            wx.wxRect(1,2,3,4); r1.PrintXY = wxRect_PrintXY_func;
            r1:PrintXY()</CODE>. You can see that using this idea you can write
            a Lua function that creates a new wxRect, sets your extra functions
            for it, and returns it for use.</LI>
          </UL>
        </LI>
      </UL>
    </LI>
  </UL>

  <H2><A name="C6" id="C6"></A>6 - wxLua Samples and How to Run Them</H2>There
  are a number of sample programs in the <I style=
  "font-style: italic;">wxLua/samples</I> directory. These programs demonstrate
  how to write simple programs and try to show how to use some of the many
  classes of wxWidgets. They are a good resource to learn how to write your own
  more complicated programs.<BR>
  <BR>
  We welcome any enhancements or additional samples that might be generally
  useful to the wxLua community. Please understand that any code you contribute
  has to be maintained and easily understood, so try to keep things simple and
  clear.<BR>
  <BR>
  If something in wxLua seems to not work as expected it is best to try to
  duplicate your error in the simplest possible way in one of the samples and
  ask on the <I>wxlua-users@lists.sourceforge.net</I> mailing list.<BR>
  <BR>
  Why are the samples named <I>sample.wx.lua</I>? To allow them to be colorized
  correctly in syntax highlighting editors, yet denote to people that they are
  for wxLua and must be run using a wxLua executable or the wxLua module.<BR>

  <H3><A name="C6.1" id="C6.1"></A>6.1 - How to Run the Samples</H3>The
  examples below are for MS Windows .exe executables, but the same applies for
  Linux or OSX, just remove the .exe extension from the executable. See also
  <A href="wxlua.html#C7">wxLua Applications</A> for more information about
  these programs.

  <UL>
    <LI>On the command line run <B><I>$wxlua.exe sample.wx.lua</I></B></LI>

    <LI>On the command line run <B><I>$wxluafreeze.exe
    sample.wx.lua</I></B></LI>

    <LI>Open the Lua program in <B>wxlua.exe</B> and choose the menu item
    Run.</LI>

    <LI>Open the Lua program in <B>wxluaedit.exe</B> and select the menu item
    wxLua-&gt;Run or press the toolbar "play" button to run it.</LI>

    <LI>Use wxLua as a Lua module (using the function require), run
    <B><I>$lua.exe sample.wx.lua</I></B>

      <UL>
        <LI>In order to use wxLua as a module the Lua code must have
        <CODE class="codelua">require("wx")</CODE> to load the wxLua bindings
        in the beginning and <CODE class=
        "codelua">wx.wxGetApp():MainLoop()</CODE> at the end to start the
        wxWidgets event loop.</LI>

        <LI>You may need to adjust the <CODE class=
        "codelua">package.cpath</CODE> variable to have it point to the correct
        location of the wx.so or wx.dll shared library for <CODE class=
        "codelua">require("wx")</CODE> to load.</LI>
      </UL>
    </LI>
  </UL>

  <H3><A name="C6.2" id="C6.2"></A>6.2 - Provided Samples</H3>

  <UL>
    <LI>
      <B>bindings.wx.lua</B>

      <UL>
        <LI>This is a MUST use program, at least once, to get a better
        understanding of the bindings.</LI>

        <LI>Lets you explore the C++ binding structs from within Lua using a
        wxListCtrl. This program shows the raw data that is used to push the
        bindings into Lua when a wxLuaState is created.</LI>

        <LI>Take note of the menu item "Show Lua stack dialog..." and the code
        for it. You can use this dialog to debug your own programs by viewing
        the stack, local and global variables, as well as the Lua registry
        which is only accessible in C.</LI>
      </UL>
    </LI>

    <LI>
      <B>calculator.wx.lua</B>

      <UL>
        <LI>A simple calculator program that demonstrates loading and using
        controls from an XRC resource, accelerator tables, and event
        handling.</LI>

        <LI>This programs loads the file calculator.xrc to create its GUI.</LI>
      </UL>
    </LI>

    <LI>
      <B>choices.wx.lua</B>

      <UL>
        <LI>Demonstrates a number of controls that offer choices to the user,
        wxRadioBox, wxListBox, wxComboBox, wxChoice, and wxCheckListBox.</LI>

        <LI>It uses a wxNotebook and wxSizers for layout.</LI>
      </UL>
    </LI>

    <LI>
      <B>coroutine.wx.lua</B>

      <UL>
        <LI>A demo of how to use coroutines in wxLua using wxEVT_IDLE to call
        coroutine.resume().</LI>
      </UL>
    </LI>

    <LI>
      <B>dialog.wx.lua</B>

      <UL>
        <LI>A simple temperature conversion program to/from Fahrenheit to/from
        Celsius. Shows the use of wxSizers, wxButtons, and the wxTextCtrl.</LI>
      </UL>
    </LI>

    <LI>
      <B>editor.wx.lua</B>

      <UL>
        <LI>This is the editor that the wxLua application <I>apps/wxlua</I>
        uses.</LI>

        <LI>It uses the wxStyledTextCtrl for the editor and can run and debug
        Lua programs.</LI>

        <LI>For more information see the wxLua application notes below.</LI>
      </UL>
    </LI>

    <LI>
      <B>grid.wx.lua</B>

      <UL>
        <LI>A very simple demo of the wxGrid class.</LI>
      </UL>
    </LI>

    <LI>
      <B>htmlwin.wx.lua</B>

      <UL>
        <LI>Shows the wxLuaHtmlWindow and it's virtual functions as well as
        adding custom widgets to a wxHtmlWindow.</LI>
      </UL>
    </LI>

    <LI>
      <B>luamodule.wx.lua</B>

      <UL>
        <LI>A sample for loading the wxLua "wx" module using Lua's require
        function when wxLua is compiled as a shared library.</LI>

        <LI>Run this program using the Lua executable and not wxLua or
        wxLuaFreeze since the wxLua library is loaded at run-time.</LI>

        <LI>See also wrapmodule.wx.lua for more information about loading Lua
        modules.</LI>
      </UL>
    </LI>

    <LI>
      <B>mdi.wx.lua</B>

      <UL>
        <LI>Shows the MDI classes, wxMDIParentFrame and wxMDIChildFrame.</LI>
      </UL>
    </LI>

    <LI>
      <B>media.wx.lua</B>

      <UL>
        <LI>A sample for the wxMediaCtrl that can load and play audio and video
        files.</LI>
      </UL>
    </LI>

    <LI>
      <B>minimal.wx.lua</B>

      <UL>
        <LI>A minimal sample that creates a wxFrame, wxMenuBar, and
        wxStatusBar.</LI>
      </UL>
    </LI>

    <LI>
      <B>printing.wx.lua</B>

      <UL>
        <LI>Demonstrates how to use the printing architecture and some wxDC
        drawing classes in wxLua.</LI>
      </UL>
    </LI>

    <LI>
      <B>scribble.wx.lua</B>

      <UL>
        <LI>A simple drawing program that shows how to handle wxMouseEvents and
        wxDC drawing as well as creating a custom control.</LI>
      </UL>
    </LI>

    <LI>
      <B>sizer.wx.lua</B>

      <UL>
        <LI>A simple wxSizer demonstration.</LI>
      </UL>
    </LI>

    <LI>
      <B>tree.wx.lua</B>

      <UL>
        <LI>A wxTreeCtrl demonstration.</LI>
      </UL>
    </LI>

    <LI>
      <B>wrapmodule.wx.lua</B>

      <UL>
        <LI>This is a wrapper program to allow you to use the wx shared library
        as a Lua module (using require) to run the provided samples without
        having to edit them.</LI>

        <LI>See <A href="#How_to_run_the_samples">How to Run the Samples</A>
        for other ways to run the samples.</LI>

        <LI>The search path for the module may need to be specified if it is
        not in the same directory as the sample you want to run.

          <UL>
            <LI>You can add a line like the one below to the top of
            wrapmodule.wx.lua (adjusted as necessary) for your paths.</LI>

            <LI>The list of paths is a semicolon separated list of paths to
            <B>?.so</B> (for Unix type shared libraries) and <B>?.dll</B> (for
            MSW) .</LI>

            <LI>? is equivalent to * meaning match anything for typical shells
            (DOS prompt).</LI>

            <LI>You might as well include paths to both unfix and MSW libraries
            so that the script can be run on either platform without
            modification since typically only the libraries that work on any
            given platform will be installed.</LI>

            <LI>package.cpath =
            ";;../lib/?.so;../lib/vc_dll/?.dll;../lib/bcc_dll/?.dll;../lib/mingw_dll/?.dll;"</LI>
          </UL>
        </LI>
      </UL>
    </LI>

    <LI>
      <B>unittest.wx.lua</B>

      <UL>
        <LI>Tests that the binding generator is working properly as well as
        wxLua itself.</LI>

        <LI>This is also a good reference for how to call various objects since
        it tries to test all the valid methods.</LI>
      </UL>
    </LI>

    <LI>
      <B>validator.wx.lua</B>

      <UL>
        <LI>Tests the wxGenericValidator and wxTextValidator.</LI>
      </UL>
    </LI>

    <LI>
      <B>veryminimal.wx.lua</B>

      <UL>
        <LI>A wxFrame only.</LI>
      </UL>
    </LI>

    <LI>
      <B>wxluasudoku.wx.lua</B>

      <UL>
        <LI>A complete Sudoku solver and program to play Sudoku puzzles. This
        program demonstrates most things that might be required for typical GUI
        programs; drawing, printing, event handling, custom dialogs, key and
        mouse events, menu, toolbar, statusbar, etc...</LI>

        <LI>The program is broken into two parts and the code put in two
        separate Lua tables to make things easier to understand. The sudoku
        solver code is in the "sudoku" table at the top of the listing and the
        wxWidgets GUI code in the "sudokuGUI" table at the bottom.</LI>
      </UL>
    </LI>
  </UL>

  <H2><A name="C7" id="C7"></A>7 - wxLua Applications</H2>The applications that
  wxLua provides are in the <I>wxLua/apps</I> directory. These are C++ programs
  that are compiled against the wxWidgets library and the wxWidgets
  wxStyledTextCtrl library.<BR>

  <UL>
    <LI>
      <H3><A name="C7.1" id="C7.1"></A>7.1 - wxLua</H3>

      <UL>
        <LI>This is a wxLua IDE editor program written in Lua that has a nice
        editor using the wxStyledTextCtrl.</LI>

        <LI>The Lua code for it is in samples/editor.wx.lua</LI>

        <LI>You can fully debug Lua programs, step through them line by line,
        set break points, view call stack, etc.</LI>

        <LI>The <I>File</I>, <I>Edit</I>, and <I>Search</I> menus offer typical
        editor functionality.</LI>

        <LI>The <I>Debug</I> menu contains the items to run and debug your
        programs

          <UL>
            <LI><I>Compile</I> - test compilation of your program, does not run
            it, but checks the Lua syntax.</LI>

            <LI>
              <I>Run</I> - Run the current program independently in a separate
              process.

              <UL>
                <LI>The wxLua program is run with the command '$wxLua
                editor_filename' and therefore you need to have saved it to
                disk.</LI>
              </UL>
            </LI>

            <LI><I>Attach</I> - Attach the debugger to a process, you must
            start the debuggee process by hand by running another wxLua process
            as "wxLua -dHOSTNAME:PORT program.lua" using the appropriate values
            for HOSTNAME:PORT as shown in the wxLua status window after
            selecting <I>Attach</I>. You can abort the debugging by selecting
            <I>Stop Debugging</I>.</LI>

            <LI>
              <I>Start Debugging</I> - Start debugging the current program
              where you can then <I>Step, Step Over, Continue, Break</I>.

              <UL>
                <LI>A TCP debugger server is started on a port in the range
                1551-1559 listening for a connection from the localhost.</LI>

                <LI>A new wxLua process is created (see <I>Attach</I>) as a
                debuggee client and the code in the current editor is sent to
                the debugee to run.</LI>
              </UL>
            </LI>

            <LI><I>Console</I> - Use a dialog with a text control to show the
            output from Lua print statements when running or debugging
            programs.</LI>

            <LI><I>Stop Debugging</I> - Stop debugging and close the debuggee
            process.</LI>

            <LI><I>Step</I> - Take one step in debugging the program.</LI>

            <LI><I>Step Over</I> - Step over a function call.</LI>

            <LI><I>Step Out</I> - Step out of a function call.</LI>

            <LI><I>Continue</I> - Continue running the program.</LI>

            <LI><I>Break</I> - Break a running program.</LI>

            <LI><I>View Call Stack</I> - View the current call stack of a Lua
            program being debugged showing all variables and their values.</LI>

            <LI><I>View Watches</I> - Set and view watches of variables for the
            Lua program being currently debugged.</LI>

            <LI><I>Show Output Window</I> - Show or hide the output window for
            messages during debugging.</LI>

            <LI><I>Clear Output Window</I> - When checked, clear the text in
            the output window when starting to debug.</LI>
          </UL>
        </LI>

        <LI>This program can also run Lua or wxLua programs on the command line
        just like the Lua executable.

          <UL>
            <LI>The command line switches can be displayed by running wxLua
            -h.</LI>

            <LI>The editor is run if no parameters are given.</LI>

            <LI>Note that the switches -c (print console), -q (don't quit if no
            top level window open), -e (execute Lua code) must be specified
            before -d, -o, -r</LI>

            <LI>The switches -d (run as debuggee), -o (open files to edit), and
            -r (run file) are exclusive and you can only use one.</LI>

            <LI>If -d, -o, or -r are not given but there is at least one
            parameter on the command line, it is interpreted to be a program
            name and wxLua will try to run it, any parameters after the program
            name are pushed into the Lua as a table named 'arg'.

              <UL>
                <LI><I>wxLua editor.wx.lua</I> is the same as just running
                <I>wxLua</I> itself. You can run the editor this way to
                customize it, but please don't forget to post any enhancements
                to the wxlua-users mailing list so they can be incorporated
                back into wxLua.</LI>
              </UL>
            </LI>

            <LI>If you want to run a program or provide arguments to your Lua
            program that use -X or /X semantics you need to use -- to stop the
            wxLua program from interpreting the args.

              <UL>
                <LI>In the example below, we don't want wxLua to interpret the
                second -c or give an error for the -g arg, but rather pass the
                args to myprogram.lua.</LI>

                <LI>
                  <I>wxLua -c -e "a = 12; b = 3" -- myprogram.lua -c 12
                  -g</I><BR>

                  <UL>
                    <LI>The wxLua program will display a console window to
                    display print statements, run the string "a = 12; b = 3",
                    then run myprogram.lua and push into Lua a table named
                    'arg' with the indices</LI>

                    <LI>[-5] = 'd:\wxLua\bin\wxlua.exe', [-4] = '-c', [-3] =
                    '-e', [-2] = 'a = 12; b = 3', [-1] = '--', [0] =
                    '../samples/unittest.wx.lua'</LI>

                    <LI>[1] = '-c', [2] = '12', [3] = '-g'</LI>

                    <LI>This is the same table the Lua executable creates,
                    where arg[0] is the name of the Lua program run and
                    positive indices are args to the Lua program and the most
                    negative index is the name of the executable.</LI>
                  </UL>
                </LI>

                <LI>wxLua -c -e "a = 12; b = 3" -r myprogram.lua -- -c 12 -g

                  <UL>
                    <LI>Gives the same results, but the Lua arg table starts
                    with [1] = '--' which should probably be ignored.</LI>
                  </UL>
                </LI>
              </UL>
            </LI>
          </UL>
        </LI>
      </UL>
    </LI>

    <LI>
      <H3><A name="C7.2" id="C7.2"></A>7.2 - wxLuaEdit</H3>

      <UL>
        <LI>This is another IDE type program written in C++ that runs wxLua
        programs in the main thread and can therefore be "dangerous." However
        it works fairly well and uses wxYield events to keep the editor GUI
        responsive while running, though this does sacrifice speed. It does not
        allow step-by-step debugging of Lua programs. However, it does provide
        a Lua shell to try things out very quickly and you can interactively
        manipulate or introspect a program as it runs in the "Output"
        window.</LI>

        <LI><I>Run wxLua Program</I> - Runs the program in the current notebook
        tab and outputs any print or error messages to the "Output" window. A
        new lua_State is created for each run and is accessible in the Output
        window until a new one is run.</LI>

        <LI><I>Stop wxLua Program</I> - Stops the currently running wxLua
        program. This only stops the program if Lua is actually running meaning
        that the Lua parser is running. Once you've created a top level window
        the wxWidgets event system runs in the background and calls the
        wxLuaState as necessary for event handling. This is why Lua is
        considered to be not running even though your programing is
        "running."</LI>

        <LI><I>Stack Tree</I> - Show the stack of the current lua_State.
        Current means which output window you're looking at, either the Shell
        or the Output.</LI>

        <LI><I>Toggle Breakpoint</I> - Add a breakpoint to the line of code and
        when the Lua parser reaches it throw an error. You can then use the
        print() statement in the Output window or the stack tree to view the
        current state of Lua. You cannot view local variables however and
        apparently this is a limitation of Lua itself. You cannot also continue
        running the program.</LI>

        <LI>The editor uses the wxStEdit library from wxcode.sourceforge.net
        for the editor. You need to download either the newest version or use
        CVS to get a copy from wxcode.sourceforge.net in order to compile this
        editor.</LI>
      </UL>
    </LI>

    <LI>
      <H3><A name="C7.3" id="C7.3"></A>7.3 - wxLuaFreeze</H3>

      <UL>
        <LI>This is the simplest incarnation of a wxLua program that makes use
        of the wxLua library. Once compiled, it can run Lua programs on the
        command line as <I>$wxLuaFreeze program.lua</I>. Additionally you can
        use the <I>wxluafreeze.lua</I> script to append a single file Lua
        program to the end of wxLuaFreeze to run. Please see <I>readme.txt</I>
        in <I>apps/wxluafreeze</I> and also either run <I>wxluafreeze.lua</I>
        with no arguments or read the the Usage() function in it. You should
        give the output of <I>wxluafreeze.lua</I> a new name so you don't
        modify the original, though you may do this if you like. Once a program
        has been "frozen" to the end of wxLuaFreeze it automatically runs it
        and any arguments passed to it on the command line are pushed into Lua
        as the args table. For MSWindows a program called upx can be used to
        compress the executable to about 1.5 Mb from 4.5 Mb, using VC6 in
        release mode as the compiler.</LI>
      </UL>
    </LI>
  </UL>

  <H2><A name="C8" id="C8"></A>8 - wxLua Utils</H2>Utility programs for wxLua
  are located in the <I>wxLua/util</I> directory.

  <UL>
    <LI>
      <H3><A name="C8.1" id="C8.1"></A>8.1 - bin2c.lua</H3>

      <UL>
        <LI>bin2c.lua is a Lua program to convert a file into a const char*
        string to be included into a C/C++ program.</LI>

        <LI>You can then run the script in C++ by calling
        <I>wxLuaState::LuaDoBuffer(string_var, string_len, "Lua
        program")</I>.</LI>

        <LI>Help is shown if no arguments are given when run or you can read
        its Usage() function.</LI>
      </UL>
    </LI>
  </UL>

  <H2><A name="C9" id="C9"></A>9 - wxLua Sourcecode Modules</H2>wxLua is broken
  up into "modules" that are compiled into libraries so that you can choose to
  link to some or all of them. The directory structure of the <I>modules</I>
  dir is such that you need only add the #include path to <I>wxLua/modules</I>
  in your compiler settings and then in the code always write <I>#include
  "modulename/include/filename.h"</I>.<BR>

  <UL>
    <LI>
      <B>Lua</B>

      <UL>
        <LI>The source code of Lua itself. It is the original unmodified source
        for the version, with some of the header files copied to the include
        directory for the installation routines.</LI>

        <LI>Patches released for the version are applied as they come out, see
        <I>wxLua/docs/changelog.txt</I>.</LI>

        <LI>Compilation of this module generates a Lua library and two
        executables, lua.exe and luac.exe.</LI>
      </UL>
    </LI>

    <LI>
      <B>wxbind</B>

      <UL>
        <LI>The output of the interface files in
        <I>wxLua/bindings/wxwidgets</I> are generated in this directory. They
        are the wrappers for the wxWidgets library.</LI>

        <LI>You do not need to regenerate them unless you have edited the
        interface files themselves.</LI>

        <LI>You should NOT edit these files directly as they will be
        overwritten if you regenerate the bindings, the fix should really go
        into the interface files themselves.</LI>

        <LI>To initialize this library in a C++ program and have it pushed into
        Lua you should have the code <I>"extern bool
        wxLuaBinding_wxXXX_init();"</I> and then somewhere in your app
        initialization or at least before you create a wxLuaState call
        <I>wxLuaBinding_wxXXX_init()</I>. This is because different compilers
        seem to have problems with the various techniques we've tried to
        automatically initialize the binding and may even throw out the whole
        library when linking unless you explicitly use something in it. Replace
        the XXX with the name of the library you want installed, see
        modules/wxbind/include/wxbinddefs.h for a list of them.</LI>

        <LI>You should preferably use the macros in
        modules/wxbind/include/wxbinddefs.h to make it easy to install a
        standard set of them or all of them. They do some simple checks to
        determine if the binding will be available based on the wxWidgets
        wxUSE_XXX directives.</LI>

        <LI>Compilation of this module generates a number of libraries
        corresponding to the libraries that wxWidgets generates, wxadv, wxaui,
        wxbase, wxcore, wxgl, wxhtml, wxmedia, wxnet, wxstc, wxxml, and
        wxxrc.</LI>
      </UL>
    </LI>

    <LI>
      <B>wxlua</B>

      <UL>
        <LI>This is the core library of wxLua itself. It contains the
        wxLuaState class and helper functionality.</LI>

        <LI>You must at least link to this library.</LI>

        <LI>The public C++ side of wxLua is almost entirely contained in
        <I>modules/wxlua/include/wxlstate.h</I>.</LI>

        <LI>This library also contains some bindings that are useful for
        debugging and getting information about wxLua.</LI>

        <LI>To initialize this library in a C++ program and have it pushed into
        Lua you should have the code <I>"extern bool
        wxLuaBinding_wxlua_init();"</I> and then somewhere in your app
        initialization or at least before you create a wxLuaState call
        <I>wxLuaBinding_wxlua_init()</I>.</LI>

        <LI>Compilation of this module generates a wxlua library.</LI>
      </UL>
    </LI>

    <LI>
      <B>wxluadebug</B>

      <UL>
        <LI>This is a simple debug library for Lua that provides some tools and
        a widget for showing the stack and browsing the locals, globals, and
        registry variables.</LI>

        <LI>Compilation of this module generates a wxluadebug library.</LI>
      </UL>
    </LI>

    <LI>
      <B>wxluasocket</B>

      <UL>
        <LI>This is a socket library for one wxLua program to communicate with
        another for debugging purposes. It is currently used in the wxlua app
        (samples/editor.wx.lua).</LI>

        <LI>This lib depends on the wxluadebug lib.</LI>

        <LI>To initialize this library in a C++ program and have it pushed into
        Lua you should have the code <I>"extern bool
        wxLuaBinding_wxluasocket_init();"</I> and then somewhere in your app
        initialization or at least before you create a wxLuaState call
        <I>wxLuaBinding_wxluasocket_init()</I>.</LI>

        <LI>Compilation of this module generates a wxluasocket library.</LI>
      </UL>
    </LI>
  </UL>

  <H2><A name="cpp_programming_guide" id="cpp_programming_guide"></A> <A name=
  "C10" id="C10"></A>10 - wxLua C++ Programming Guide</H2>The documentation for
  the wxLua library is in the header files and descriptions are given for each
  function, enum, etc. Please read through them to get a feel for what
  functions wxLua provides. Below is a brief synopsis of wxLua for C++
  programmers.<BR>
  <BR>
  Lua uses char strings while wxWidgets uses the wxString class which uses the
  wxChar data type. Depending on whether you have compiled wxWidgets in Unicode
  mode or not, wxChar can be either wchar or char. Therefore, wxLua uses the
  functions <I>"wxString lua2wx(const char* str)"</I> and <I>"const
  wxCharBuffer wx2lua(const wxString&amp; str)"</I> to translate between the
  two. Note that wxCharBuffer can be used as a const char* string directly
  without any casting.<BR>
  <BR>
  The core of wxLua is based upon a ref counted wxLuaState class derived from
  the wxWidget's wxObject class. The wxLuaState class contains as a member of
  its ref data the 'C' lua_State struct which is the heart of Lua. Since the
  class is ref counted, it should be passed as <I>const wxLuaState&amp;</I> and
  can be used in much the same way as a wxBitmap, wxPen, or any of the other
  wxObject derived classes that make use of its ref counting mechanism. What
  this means for wxLua is that instead of keeping pointers to the lua_State you
  have instances of the wxLuaState, there is a slight overhead for this, but it
  is minimal. When the lua_State is closed, all the wxLuaStates sharing the ref
  data can check their ref data to see if the lua_State is NULL and segfaults
  from dangling pointers are avoided. The reason why this is a good idea is
  that wxWidgets has delayed wxWindow deletion and things can get out of order.
  Care must be taken for pushed event handlers from Lua because if the
  lua_State is closed, but the window hasn't been deleted just yet... It's best
  to have a way to check and the wxLuaState wraps this all up.<BR>
  <BR>
  When the wxLuaState is Ok() the wxLuaState has its ref data and the lua_State
  is created. If it's not Ok() then most wxLuaState functions will assert in
  debug mode, so it's always best to compile in debug mode until you're sure
  things are working properly.<BR>
  <BR>
  The wxLuaState contains all of the Lua 'C' functions, such as
  lua_gettop(lua_State* L), but as member functions named lua_GetTop() which
  use the internal lua_State and check for its validity before use. The
  functions are capitalized to make them easier to find in an editor. If you
  want the greatest performance just use wxLuaState::GetLuaState() and directly
  manipulate the returned pointer to the lua_State.<BR>
  <BR>
  It is instructive to follow the creation of the wxLuaState by looking at bool
  wxLuaState::Create(wxEvtHandler *handler, wxWindowID id) in
  <I>wxLua/modules/wxlua/src/wxlstate.cpp</I>.<BR>

  <OL>
    <LI>The lua_State is created using lua_open() and then the standard Lua
    libraries are loaded, base, table, string, math, and so on using
    luaL_openlibs(L) as well as luaopen_bit(L) to open the bit library we
    use.</LI>

    <LI>The function wxLuaState::Create(L, wxLUASTATE_USESTATE) is called to
    finish setting up the lua_State.

      <OL>
        <LI>The wxObject::m_refData is created as a new wxLuaStateRefData().
        This ref data class contains a pointer to the lua_State struct and to a
        shared wxLuaStateData class that is also created. If a Lua program
        running in this wxLuaState creates coroutines, each will have their own
        wxLuaStateRefData and associated lua_State, but they will all share the
        same wxLuaStateData class.</LI>

        <LI>The C lua_State is added to a hash table to allow looking up the
        owner wxLuaStateRefData when Lua calls the C wxLua binding functions
        with the lua_State as the only parameter. A new wxLuaState with the
        wxLuaStateRefData set using wxObject::SetRefData(), which does not
        "ref" the data, but simply sets it, is used since we do not want an
        extra "ref". The same wxLuaState is pushed into the LUA_REGISTRYINDEX
        table as a lightuserdata using the &amp;wxlua_lreg_wxluastate_key as a
        secondary means to find the wxLuaState "owner" of the lua_State which
        will be used for coroutines since there is no way to determine when a
        coroutine (new lua_State) is created and then destroyed.</LI>

        <LI>The tables and values that wxLua uses to store information about
        the bindings or track its state are pushed into the LUA_REGISTYINDEX.
        Information about these items can be found in the next section.</LI>

        <LI>We register a print() function for Lua to get the output of Lua
        print() statements to send messages as wxLuaEvents, see
        wxEVT_LUA_PRINT.</LI>
      </OL>
    </LI>

    <LI>The bindings are registered by calling wxLuaState::RegisterBindings().

      <UL>
        <LI>Each binding that is loaded are derived wxLuaBinding classes whose
        member data variables point to structs in each binding. A single static
        instance of each binding class are installed into a wxList when the
        wxLuaBinding_XXX_init() functions are called. The reason behind the
        need for running the init function from the binding libraries is to
        stop certain compilers from throwing out the whole binding library,
        which happens even if the binding was added to the list from within the
        library.</LI>
      </UL>

      <OL>
        <LI>Each binding has wxLuaBinding::RegisterBinding(...) called for it.

          <UL>
            <LI>luaI_openlib(L, binding_namespace, fake luaL_Reg, 0) ; is
            called to have Lua create the tables that we will install the
            bindings into. This allows wxLua to look like a standard Lua
            library even though it works a little differently.

              <UL>
                <LI>LUA_REGISTRYINDEX["_LOADED"][binding_namespace] =
                table</LI>

                <LI>LUA_GLOBALSINDEX[binding_namespace] = table</LI>

                <LI>LUA_GLOBALSINDEX["package"]["loaded"][binding_namespace] =
                table</LI>
              </UL>
            </LI>

            <LI>wxLuaBinding::DoRegisterBinding(...) is called to actually push
            the bindings into the binding_namespace table we've created in
            Lua.</LI>
          </UL>
        </LI>
      </OL>
    </LI>

    <LI>At the end of creation a wxLuaEvent is sent with the wxEVT_LUA_CREATION
    event type.</LI>
  </OL>

  <H3><A name="C10.1" id="C10.1"></A>10.1 - Data stored in Lua's
  LUA_REGISTRYINDEX table</H3>wxLua stores its book keeping data in the Lua's
  LUA_REGISTRYINDEX table that the wxLuaState creates and uses. The keys are
  const char* strings with its address pushed as a light userdata because a
  pushing the string itself requires that it be hashed and it was found to take
  a considerable amount of the total time of a function call. A list of all of
  the tables is at the top of the wxlstate.h header file.<BR>
  <BR>

  <H3><A name="C10.2" id="C10.2"></A>10.2 - Functions to Create a
  wxLuaState</H3>

  <UL>
    <LI>wxLuaState(bool create = false)

      <UL>
        <LI>If create is false, default constructor, you must call Create(...)
        to actually use it.</LI>

        <LI>If create is true, you now have a working wxLuaState, i.e. a
        lua_State, with all the bindings attached.</LI>
      </UL>
    </LI>

    <LI>wxLuaState(wxEvtHandler *handler, wxWindowID id = wxID_ANY)

      <UL>
        <LI>Creates a complete wxLuaState, but you can provide an event
        handler, e.g. a wxApp or wxWindow derived class, to get and handle the
        wxLuaEvents, see also Get/SetEventHandler().</LI>
      </UL>
    </LI>

    <LI>wxLuaState(lua_State* L, wxLuaState_Type type = wxLUASTATE_GETSTATE)

      <UL>
        <LI>type = wxLUASTATE_GETSTATE means that the lua_State must already
        have been created using a wxLuaState and so this new wxLuaState will
        merely attach to the corresponding ref data.</LI>

        <LI>type = wxLUASTATE_SETSTATE means that this new lua_State that you
        have created will have the wxLua bindings pushed into it if
        wxLUASTATE_OPENBINDINGS is set and then be ready for running wxLua
        programs. The wxLuaState will not close the lua_State, but will remove
        itself from Lua and do cleanup when there are no more instances of them
        if wxLUASTATE_STATICSTATE is set.</LI>
      </UL>
    </LI>
  </UL>

  <H3><A name="C10.3" id="C10.3"></A>10.3 - Using a wxLuaState</H3>

  <UL>
    <LI>int LuaDoString(const wxString &amp;script, const wxString&amp; name =
    wxEmptyString)

      <UL>
        <LI>Runs the script as a string with the given name. The name is only
        used if Lua errors out and then the debug message will contain that
        name.</LI>

        <LI>Returns Lua's error code LUA_ERRXXX or 0 on success</LI>
      </UL>
    </LI>

    <LI>int LuaDoBuffer(const char *buffer, size_t len, const char *name)

      <UL>
        <LI>Run a buffer, perhaps from bin2lua.lua, that you've compiled with
        your program.</LI>

        <LI>Returns Lua's error code LUA_ERRXXX or 0 on success</LI>
      </UL>
    </LI>

    <LI>int LuaDoFile(const wxString &amp;filename)

      <UL>
        <LI>Run a Lua file from disk.</LI>

        <LI>Returns Lua's error code LUA_ERRXXX or 0 on success</LI>
      </UL>
    </LI>

    <LI>int LuaPCall(int narg, int nresults)

      <UL>
        <LI>Uses lua_call to run a chunk on the stack, but sets things up for
        wxLua first.</LI>

        <LI>Returns Lua's error code LUA_ERRXXX or 0 on success</LI>
      </UL>
    </LI>

    <LI>There are many other functions which are documented in
    <I>wxLua/modules/wxlua/include/wxlstate.h</I>.</LI>
  </UL>
</BODY>
</HTML>
