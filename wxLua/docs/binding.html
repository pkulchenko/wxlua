<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<HTML>
<HEAD>
  <META name="generator" content=
  "HTML Tidy for Linux (vers 25 March 2009), see www.w3.org">
  <META content="text/html; charset=us-ascii" http-equiv="content-type">

  <TITLE>wxLua Binding HowTo</TITLE>
  <META content="John Labenski" name="author">
  <META content="Info wxWidgets bindings to wxLua" name="description">
  <LINK rel="stylesheet" type="text/css" href="wxlua.css">
</HEAD>

<BODY>
  <H1><U>wxLuaBinding 2.8.12 - Writing and Generating Binding Files</U></H1>

  <DIV style="text-align: justify;">
    The binding generator for wxLua provides information for Lua code to
    interface to a C/C++ API. The C/C++ objects are created in Lua as userdata
    and manipulated using the same functional semantics as you would in C/C++.
    The <A href="wxlua.html">wxlua.html</A> wxLua documentation describes in
    detail how the object will be named and where it will be placed in Lua.<BR>
    <BR>
    Binding files are provided for the <B>wxWidgets</B> cross platform GUI
    library and the wxStyledTextCtrl contrib library of the wxWidgets library.
    You may also write and add your own bindings to use wxLua as a scripting
    language in your own C++ project. There is an example of this in the
    <I>apps/wxluacan/src</I> directory.<BR>
    <BR>
    The interface files are skeletons of the C/C++ header files that the
    program <I>bindings/genwxbind.lua</I> parses and turns into C functions
    that are imported into Lua by an automatically generated
    <I>wxLuaBinding</I> derived class. The whole process of generation is
    automatic and no editing of the output files should be required. If there
    is any problem you should fix the interface files and regenerate instead of
    trying to fix the generated files. Some examples of the interface files are
    in the <I>bindings/wxwidgets/*.i</I> directory. Before writing your own,
    take some time to examine them to see the differences between them and the
    original C++ code. If the automatic bindings do not generate suitable code
    for a specific function, you can <I>%override</I> individual function
    bindings with your own code to implement it in any way you want.<BR>
  </DIV>

  <H2>Table of Contents</H2>

  <DIV class="greybox">
    <OL>
      <LI><A href="binding.html#C1">1 - Binding File Descriptions</A></LI>

      <LI><A href="binding.html#C2">2 - Generated Files</A></LI>

      <LI><A href="binding.html#C3">3 - Binding C++ Virtual Functions</A></LI>

      <LI>
        <A href="binding.html#C4">4 - Interface File Constructs</A>

        <OL type="a">
          <LI><A href="binding.html#C4.1">4.1 - Special Function
          Parameters</A></LI>

          <LI><A href="binding.html#C4.2">4.2 - C++ Class Member Function
          Directives</A></LI>

          <LI><A href="binding.html#C4.3">4.3 - Comments</A></LI>

          <LI><A href="binding.html#C4.4">4.4 - Interface Tags</A></LI>
        </OL>
      </LI>
    </OL>
  </DIV>

  <H2><A name="C1" id="C1"></A>1 - Binding File Descriptions</H2>

  <H3>bindings/genwxbind.lua</H3>

  <UL>
    <LI>The binding file generator that converts the *.i interface files into a
    set of C++ files to be compiled into a library and linked to or compiled
    along with your program.</LI>

    <LI><I>bindings/wxwidgets/wxbase_rules.lua</I> (for example) is a rules
    file that determines where and what interface files <I>genwxbind.lua</I>
    should read, how it should name the output files and generated classes,
    what extra header code to add, among other things. Documentation for
    creating a rule file is provided inside the ones provided by wxLua and you
    should copy an existing one to use as a starting point for your own.</LI>

    <LI>The rules files are actual Lua programs that <I>genwxbind.lua</I> runs
    before processing the interface files, but after it has created various
    structures used for parsing allowing for customization by either adding to
    the structures or changing them.</LI>

    <LI>Command line usage of genwxbind.lua

      <UL>
        <LI>lua -e"rulesFilename=\"wxwidgets/wx_rules.lua\"" genwxbind.lua</LI>

        <LI>Informational messages, warnings, and errors are printed to the
        console.</LI>

        <LI>The output files are only overwritten if they differ.</LI>
      </UL>
    </LI>
  </UL>

  <H3>*.i interface files</H3>

  <UL>
    <LI>Contain a skeleton of the C/C++ functions, classes, global variables,
    #defines that should be made accessible to Lua.</LI>

    <LI>See <A href="binding.html#C4">Interface File Constructs</A> below.</LI>

    <LI>The structure of wxLua's interface files follows the wxWidgets
    documentation, typically alphabetical.

      <UL>
        <LI>Class constructors first, class member functions, %operators,
        %members.</LI>
      </UL>
    </LI>
  </UL>

  <H3>*_datatypes.lua files</H3>

  <UL>
    <LI>These are generated files that contain Lua tables of typedefs,
    datatypes, and preprocessor conditions defined in a binding that may be
    used by another binding by adding them to the
    <CODE>datatype_cache_input_fileTable</CODE> variable of the rules
    file.</LI>

    <LI>The checking of known datatypes enforces that the generated bindings
    will work correctly. If a datatype is missing it will be unusable in
    Lua.</LI>

    <LI>The items are added to the <CODE>typedefTable, dataTypeTable,</CODE>
    and <CODE>preprocConditionTable</CODE> variables of the
    <CODE>genwxbind.lua</CODE> program.</LI>

    <LI>All of the wxWidgets types are added to the
    <CODE>bindings/wxwidgets/wx_datatypes.lua</CODE> file which may be used by
    external bindings that use datatypes declared in the wxLua wxWidgets
    bindings. Note: Each <CODE>bindings/wxwidgets/wxXXX_rules.lua</CODE> file
    will generate a wxXXX_datatypes.lua datatype file, but these are all
    gathered together into the wx_datatype.lua file.</LI>
  </UL>

  <H3>wxluasetup.h</H3>

  <UL>
    <LI>Contains #defines of all of the wxLUA_USE_wxXXX for C++ compilation of
    the wxWidgets bindings.</LI>

    <LI>This file is special to wxLua's wxWidgets binding.</LI>

    <LI>If <I>wxLUA_USE_XXX</I> is 1 then it's compiled in and will be
    accessible to wxLua scripts, else skipped when compiling the generated cpp
    files to generate a smaller library.</LI>

    <LI>It provides an additional way to cut down on the size of wxLua by
    removing large parts of the bindings that will not be used. These defines
    mixed with wxWidget's own <I>wxUSE_XXX</I> #defines control what parts of
    wxWidgets is available to wxLua programs.</LI>

    <LI>For example, if you exclude <I>wxColour</I> by setting
    wxLUA_USE_wxColourPenBrush=0 then all functions that take or return a
    wxColour will be excluded, the best thing to do is to test things out and
    see what works for you.</LI>
  </UL>

  <H3>overrides.hpp</H3>

  <UL>
    <LI>Contains functions that cannot be automatically wrapped.</LI>

    <LI>You can name the file anything you want and have multiple files since
    it is specified as a table in the rules file.

      <UL>
        <LI><I>override_fileTable = { "override.hpp" }</I></LI>
      </UL>
    </LI>

    <LI>Functions that take pointers or references and return values through
    the variables passed in must be reworked to return multiple values.</LI>

    <LI>It is important to document the new signature of the overridden
    function, in wxLua we put comments like these into the interface files.

      <UL>
        <LI>// %override single_output_type ClassName::FuncName(C++ style input
        parameters)</LI>

        <LI>// %override [type1 output_name1, type2 output_name2]
        ClassName::FuncName(reworked C++ style input parameters that the Lua
        function actually takes)</LI>
      </UL>
    </LI>

    <LI>In order for the %overload functionality to work and to get the proper
    signatures; the function parameters in the .i file should match the actual
    parameters that the %override code implements. The interface files for
    wxLua always have these three lines, where the first line is for
    documentation purposes only, the second line is the original C++ function
    declaration for reference purposes to compare what wxWidgets expects to
    get, and the third line is the correct calling semantics for the
    %overridden function.

      <UL>
        <LI>// %override void wxFrame::SetStatusWidths(Lua table with number
        indexes and values)</LI>

        <LI>// C++ Func: virtual void SetStatusWidths(int n, int *widths)</LI>

        <LI>virtual void SetStatusWidths(LuaTable intTable)</LI>
      </UL>
    </LI>
  </UL>

  <H2><A name="C2" id="C2"></A>2 - Generated Files</H2>The binding generator
  genwxbind.lua generates a number of files and you can specify both their
  names and directories.<BR>

  <UL>
    <LI>A single header file is generated that typically does not have to be
    included by any files other than those generated by the bindings.

      <UL>
        <LI>Contains all the #includes and exports the tags, structs, and
        functions for use in a DLL.</LI>
      </UL>
    </LI>

    <LI>The only function that absolutely must be called is
    <B>wxLuaBinding_[hook_cpp_binding_classname]_init()</B>.

      <UL>
        <LI>It is probably easiest to declare the function using <I>extern bool
        wxLuaBinding_[hook_cpp_binding_classname]_init();</I> in your file
        rather than including the header.</LI>
      </UL>

      <UL>
        <LI>This function contains a static instance of the generated
        wxLuaBinding derived class that is put into a static wxList of
        bindings. There should only be one of the binding classes created as
        they all share the same structures anyway.</LI>

        <LI><I>static wxLuaBindingList* wxLuaBinding::GetBindingList()</I></LI>

        <LI>Note: A variety of different ways to automatically initialize the
        bindings were tried that would invariably fail with certain compilers,
        but work with others. Having to call the init function before creating
        a wxLuaState seems to work everywhere as it guarantees that when the
        bindings are compiled as a library, at least something in it is used
        and the linker won't throw the whole lib out.</LI>
      </UL>
    </LI>

    <LI>Each binding file, *.i will have a *.cpp file generated for it that
    contains:

      <UL>
        <LI>int s_wxluatag_CLASS_NAME for each class that is mapped through the
        wxLuaBindClass struct and when the binding is initialized will contain
        the tag index that Lua assigns to the class for the userdata.</LI>

        <LI>The C functions, <I>int ClassMethodFunction(lua_State* L)</I>, that
        are called for the class methods.</LI>

        <LI>A wxLuaBindMethod struct for each class to map the method function
        names to the C functions.</LI>
      </UL>
    </LI>

    <LI>A single C++ file to pull all the remaining parts together that
    contains:

      <UL>
        <LI>A wxLuaBindEvent struct that contains all the wxEventType values
        and their associated wxEvent classes to push into the Lua binding
        table.</LI>

        <LI>A wxLuaBindDefine struct that contains all the numerical values to
        push into the Lua binding table.</LI>

        <LI>A wxLuaBindString struct that contains all the strings to push into
        the Lua binding table.</LI>

        <LI>A wxLuaBindObject struct that contains all the objects to push as
        userdata into the Lua binding table.</LI>

        <LI>A wxLuaBindMethod struct that contains all the global C functions
        to push into the Lua binding table.</LI>

        <LI>A wxLuaBindClass struct that contains the class names, all the
        wxLuaBindMethod structs from each *.i generated cpp files, and their
        tags.</LI>

        <LI>A wxLuaBinding derived class that actually pushes the bindings into
        Lua.</LI>
      </UL>
    </LI>
  </UL>

  <H2><A name="C3" id="C3"></A>3 - Binding C++ Virtual Functions</H2>The only
  way to handle C++ virtual functions in wxLua is to subclass the C++ class you
  want to be able to write Lua functions for and bind the subclassed version.
  The hand coded wxLuaPrintout class is a good example of this, let's examine
  how the code in C++ and Lua works to allow you to override a C++ virtual
  function.<BR>
  The wxWidgets class wxPrintout has a number of virtual functions, but lets
  focus on "virtual bool wxPrintout::OnBeginDocument(int startPage, int
  endPage)" as an example, since if you override this function you must also
  call the base class function for printing to operate correctly. The source
  code for the class wxLuaPrintout located in
  <I>modules/wxbind/include/wxcore_wxlcore.h</I> and
  <I>modules/wxbind/src/wxcore_wxlcore.cpp</I> and you should review it before
  reading further. You will also need to look at <I>samples/printing.wx.lua</I>
  to see the Lua code that overrides the function and <SPAN style=
  "font-style: italic;">modules/wxlua/src/wxlbind.cpp</SPAN> for the metatable
  functions Lua uses to handle a call to a function.<BR>
  Below is a list of the function calls for wxPrintout::OnBeginDocument and
  notes about how it all works.<BR>

  <UL>
    <LI>Create a userdata wxLuaPrintout in Lua, replace the function
    OnBeginDocument with our own one in Lua, and begin the printing process,
    perhaps doing a print preview? The code for this is in the
    <I>printing.wx.lua</I> sample.</LI>

    <LI>The wxWidgets printing framework calls virtual
    wxPrintout::OnBeginDocument(...), but we've subclassed wxPrintout and so
    the the function wxLuaPrintout::OnBeginDocument(...) gets called.

      <UL>
        <LI>The class wxLuaPrintout keeps a refed copy of the wxLuaState from
        when it was created since otherwise the function
        wxLuaPrintout::OnBeginDocument() wouldn't know what lua_State is active
        since wxWidgets doesn't know anything about wxLua.</LI>

        <LI>In the past wxLua would iterate through a list of wxLuaStates to
        try to find the C++ userdata object, the wxLuaPrintout instance, in
        order to find the correct lua_State. This can impose a large
        performance penalty if there are multiple states and/or a large number
        of userdata objects.</LI>
      </UL>
    </LI>

    <LI>In wxLuaPrintout::OnBeginDocument() we first check to see if
    wxLuaState::GetCallBaseClassFunction() is true, if not then check to see if
    wxLuaState::HasDerivedMethod(this, "OnBeginDocument") is true, where
    <I>this</I> is the particular instance of the wxLuaPrintout class.

      <UL>
        <LI>If we're not supposed to call the base class and there is a Lua
        function that replaces "OnBeginDocument" we'll call it. First we push
        the wxLuaPrintout and the parameters to the function that's already
        been pushed on the stack by a successful call to
        wxLuaState::HasDerivedMethod() when it calls wxLuaObject::GetObject().
        We then get the result, if any, pop the result, and reset the stack to
        the starting point.</LI>

        <LI>On the other hand; if we're supposed to call the base class
        function or there isn't a derived Lua method we'll just call
        wxPrintout::OnBeginDocument(...) explicitly.</LI>
      </UL>
    </LI>

    <LI>Here's the tricky part for Lua derived functions that then call the
    base class function. In this case we're not calling the "base" class
    function of wxLuaPrintout, but rather wxPrintout since wxLuaPrintout is a
    hollow shell that merely forwards calls to Lua or to the base class.

      <UL>
        <LI>When in Lua we call <I>_OnBeginDocument(...)</I> on the
        wxLuaPrintout userdata object, the function
        wxluabind__index_wxLuaBindClass(...) in
        <I>modules/wxlua/src/wxbind.cpp</I> is called. This is the function
        that handles all function calls for wxLua userdata objects that does a
        lookup to see if the function exists and pushes it onto the stack for
        Lua to call <B>after</B> this function has returned.</LI>

        <LI>This is why we set a variable using
        wxLuaState::Set/GetCallBaseClassFunction() to remember if the Lua
        function was called with a preceding "_".</LI>

        <LI>The reason why we need to reset the GetCallBaseClassFunction() from
        within our derived C++ virtual class function is that wxWidgets may
        immediately call another C++ virtual function, but the wxLuaState is
        still flagged to call the base class and so calls to functions like
        wxLuaPrintout::OnPrintPage(...) fail since they are directed to call
        the base class function and not our derived Lua functions.</LI>
      </UL>
    </LI>
  </UL>To summarize, here's the function calls and where in each function
  wxLuaPrintout::OnBeginDocument is when you override the function in Lua.<BR>

  <UL>
    <LI>wxWidgets calls wxLuaPrintout::OnBeginDocument(...) in C++</LI>

    <LI>wxLuaPrintout::OnBeginDocument(...) runs the code to call the derived
    Lua function OnBeginDocument by calling wxLuaState::LuaCall on it.
    (GetCallBaseClassFunction() and HasDerivedMethod() are both true)</LI>

    <LI>wxluabind__index_wxLuaBindClass(...) is called when in Lua the function
    "_OnBeginPrinting" is called for the wxLuaPrintout userdata, the flag
    wxLuaState::GetCallBaseClassFunction is set to true, and the C function
    wxLua_wxPrintout_OnBeginDocument (in
    <I>modules/wxbind/src/wxcore_print.cpp</I>) is run by Lua which calls back
    to wxLuaPrintout::OnBeginDocument(...).</LI>

    <LI>We enter wxLuaPrintout::OnBeginDocument(...) a second time, the first
    time through is still stalled at wxLuaState::LuaCall() running Lua's
    OnBeginDocument() function, but this time we just call
    wxPrintout::OnBeginDocument() and return.</LI>

    <LI>The wxLuaState::LuaCall() function finishes and the first call to the
    function wxLuaPrintout::OnBeginDocument(...) returns.</LI>

    <LI>Success!</LI>
  </UL>

  <H2><A name="C4" id="C4"></A>4 - Interface File Constructs</H2>

  <H3><A name="C4.1" id="C4.1"></A>4.1 - Special Function Parameters</H3>

  <UL>
    <LI>These parameters are interpreted by the generator to implement code to
    handle a few special cases so we don't have to write overrides for
    them.</LI>

    <LI>
      <B>const wxArrayString&amp; choices or wxArrayString choices</B>

      <UL>
        <LI>The binding generator will read from Lua either a wxArrayString or
        a a numerically indexed table of strings for that parameter and convert
        them into a wxArrayString for the C++ function.</LI>

        <LI>If either <B>wxArrayString&amp; choices</B> or <B>wxArrayString*
        choices</B> is used, the generator will not do the table conversion,
        but look for a wxArrayString userdata since it's assumed that the C++
        function will modify the wxArrayString that's passed to it.</LI>
      </UL>
    </LI>

    <LI>
      <B>const wxArrayInt&amp; choices or wxArrayInt choices</B>

      <UL>
        <LI>The binding generator will read from Lua a wxArrayInt or a
        numerically indexed table of integers for that parameter and convert
        them into a wxArrayInt for the C++ function.</LI>

        <LI>If either <B>wxArrayInt&amp; choices</B> or <B>wxArrayInt*
        choices</B> is used, the generator will not do the table conversion,
        but look for a wxArrayInt userdata since it's assumed that the C++
        function will modify the wxArrayInt that's passed to it.</LI>
      </UL>
    </LI>

    <LI style="font-weight: bold;">IntArray_FromLuaTable

      <UL>
        <LI>The binding generator will read from Lua a numerically indexed
        table of integers and create two parameters (int count, int* array) to
        pass to a function.</LI>

        <LI>The int* array will be automatically deleted and the function
        should not take ownership of it and delete it itself.</LI>
      </UL>
    </LI>

    <LI>
      <B>LuaTable tableName</B>

      <UL>
        <LI>The "datatype" LuaTable does not actually exist, but is used
        exclusively for %override functions in the .i interface files. It
        directs the binding generator to expect a Lua table for that
        parameter.</LI>

        <LI>Note : You absolutely must <SPAN style=
        "font-style: italic;">%overrride</SPAN> this function as the generated
        code will not compile.</LI>

        <LI>This is useful for functions like wxFrame::SetStatusWidths as shown
        above.</LI>
      </UL>
    </LI>

    <LI style="font-weight: bold;">LuaFunction functionName

      <UL>
        <LI>The "datatype" LuaFunction does not actually exist, but is used
        exclusively for %override functions in the .i interface files. It
        directs the binding generator to expect a Lua function for that
        parameter.</LI>

        <LI>Note : You absolutely must <SPAN style=
        "font-style: italic;">%overrride</SPAN> this function as the generated
        code will not compile.</LI>
      </UL>
    </LI>

    <LI style="font-weight: bold;">voidptr_long

      <UL>
        <LI>This is for functions that take a (void *) pointer to something and
        DO NOT EVER TRY TO CAST IT, ACCESS IT, OR DELETE IT. This tag will
        allow the Lua code to put a number (perhaps a table index) as the void*
        pointer.</LI>

        <LI>See Get/SetClientData() functions in the wxWidgets bindings.</LI>
      </UL>
    </LI>
  </UL>

  <H3><A name="C4.2" id="C4.2"></A>4.2 - C++ Class Member Function
  Directives</H3>

  <UL>
    <LI>
      <B>const</B>

      <UL>
        <LI>This function attribute is ignored since wxLua doesn't create const
        objects, it's safe to leave it in the interface files as a
        reminder.</LI>
      </UL>
    </LI>

    <LI>
      <B>static</B>

      <UL>
        <LI>For class member functions inside the <I>%class</I> tag, do not use
        for C style global functions.</LI>

        <LI>The generated code will call ClassName::FunctionName() and not use
        an object.</LI>

        <LI>Example : In the %class wxFileName the function <I>"static
        wxFileName DirExists(const wxString&amp; dir)"</I>

          <UL>
            <LI>wxLua code : <SPAN style="font-style: italic;">"dir =
            wx.wxFileName.DirExists("/some/dir")"</SPAN> or <I>"f =
            wx.wxFileName(); dir = f.DirExists("/some/dir")"</I></LI>
          </UL>
        </LI>

        <LI>The bindings generate code to make the function accessible in the
        class table (first example above) as well as when called using a
        object.</LI>
      </UL>
    </LI>

    <LI>
      <B><I>virtual</I></B>

      <UL>
        <LI><I>Currently ignored - TODO perhaps</I></LI>
      </UL>
    </LI>
  </UL>

  <H3><A name="C4.3" id="C4.3"></A>4.3 - Comments</H3>

  <UL>
    <LI><B>//</B> as in C++ to comment out the rest of a line of text.</LI>

    <LI><B>/* ... */</B> to comment multiline blocks.</LI>
  </UL>

  <H3><A name="C4.4" id="C4.4"></A>4.4 - Interface
  Tags</H3><B><I>%alias</I></B> Reference a class by another name (currently
  unused).<BR>
  <BR>
  <I><B>%class [%delete] ClassName [, BaseClassName]</B> ClassName(...)<BR>
  member functions<B><BR>
  %endclass</B></I>

  <UL>
    <LI>Declare a class and optionally its base class.</LI>

    <LI>All the methods of the base class can be accessed by an instance of the
    class.</LI>

    <LI>Note: If your class is in a namespace such as ns::ClassName you must
    use %class ... ns::ClassName and the constructor must also be
    ns::ClassName. The generator will change the "::" to "_" however for useage
    in Lua.</LI>

    <LI>
      <I><B>%delete</B></I> is for classes that you want the Lua garbage
      collector to delete when the variable goes out of scope.

      <UL>
        <LI>For example, a wxPoint should be deleted when there are no longer
        any references to it, but wxWindows are typically attached to a parent
        and the parent wxWindow should delete its children, not Lua.</LI>

        <LI>Classes, like the simple wxPoint or ref counted wxObject classes
        like wxPen, can use the '=' operator to make a copy of the object.
        Therefore the bindings will make a 'new' object then copy it.</LI>

        <LI>Classes that are always "owned" by other objects that will delete
        them should not use this tag.</LI>

        <LI>Cases where a class object would be typically owned, perhaps after
        calling a function with them as a parameter, but may not start off that
        way can use the <I>%delete</I> tag, but the function that takes
        ownership should use the <I>%ungc</I> tag before the parameter.</LI>
      </UL>
    </LI>
  </UL><B><I>%define NUMBER [Value]</I></B>

  <UL>
    <LI>Adds a number to the binding table which is accessed in wxLua using
    <I>wx.NUMBER</I>.</LI>

    <LI>The <I>NUMBER</I> can be a #define or an int.</LI>

    <LI>The optional parameter <I>[Value]</I> can be the actual numerical value
    to use. This if useful when you want Lua to know about a preprocessor
    directive such as, <I>"#define A_DEFINE"</I> that doesn't have a value
    itself. In this case assign it to be 1 using <I>"%define A_DEFINE
    1"</I>.</LI>

    <LI>There are many examples of <I>%define</I> in
    <I>bindings/wxwidgets/defsutils.i</I>.</LI>
  </UL><I><B>%define_event wxEVT_XXX</B></I><BR>

  <UL>
    <LI>Declares a wxEventType <I>wxEVT_XXX</I> which can be accessed in wxLua
    using <I>wx.wxEVT_XXX</I>.</LI>

    <LI>This tag must be used inside of the %class tag for the wxEvent derived
    class it corresponds to so the event's methods can be known to Lua and the
    generator can assign the correct class type to it.</LI>

    <LI>An example of this is in the wxCommandEvent interface in
    <I>bindings/wxwidgets/event.i</I>, <I>"%define %event
    wxEVT_COMMAND_ENTER"</I>.</LI>
  </UL><I><B>%define_object OBJECT</B></I><BR>

  <UL>
    <LI>Declares an object in the binding table which can be accessed in wxLua
    using <I>wx.OBJECT</I>.</LI>

    <LI>This tag must be used inside the corresponding <I>%class</I> tag so
    that the object's class methods can be known to Lua and the generator can
    assign the correct class type to it.</LI>

    <LI>An example of this is in the wxPoint interface in
    <I>bindings/wxwidgets/gdi.i</I>, <I>"%define %object wxDefaultPosition"</I>
    where wxWidgets has created wxDefaultPosition as <I>"const wxPoint
    wxDefaultPosition;"</I>.</LI>
  </UL><I><B>%define_pointer POINTER</B></I><BR>

  <UL>
    <LI>Declares a pointer to an object in the binding table which can be
    accessed in wxLua using <I>wx.POINTER</I>.</LI>

    <LI>This tag must be used inside the corresponding <I>%class</I> tag so
    that the pointer's methods can be known to Lua and the generator can assign
    the correct class type to it.</LI>

    <LI>An example of this is in the wxPenList interface in
    <I>bindings/wxwidgets/gdi.i</I>, <I>"%define %pointer wxThePenList"</I>
    where wxWidgets has created the wxThePenList as <I>"wxPenList*
    wxThePenList;"</I>.</LI>
  </UL><I><B>%define_string STRING [Value]</B></I><BR>

  <UL>
    <LI>Adds a string to the binding table which is accessed in wxLua using
    <I>wx.STRING</I>.</LI>

    <LI>The <I>STRING</I> must be defined as <I>"const wxChar* STRING =
    _("str") or wxT("str")"</I> or some way that allows it to be converted
    easily to <I>"const wxChar*"</I> in Unicode or not.</LI>

    <LI>The optional parameter <I>[Value]</I> can be the actual string value to
    use and should be _("str"), wxT("str"), or a const wxChar* variable
    declared elsewhere.</LI>

    <LI>Note : Why not use wxString? You can't get the data from a wxString if
    you need to convert from Unicode and VC has problems having the class
    wxString as a member of a struct.</LI>

    <LI>Note : Why not use const char*? There currently isn't a need for it,
    but it would be easy to add if there was.</LI>
  </UL><I><B>%enum [Enum_Type] or [ClassName::Enum_Type]</B><BR>
  ENUM_ITEM1<BR>
  ENUM_ITEM2<BR>
  ...</I> <I><B>%endenum</B></I><BR>

  <UL>
    <LI>This adds enumerations to the binding table which can be accessed in
    wxLua using <I>wx.ENUM_ITEM1</I> as it could be in C++, meaning that the
    <I>Enum_Type</I> is stripped off.</LI>

    <LI>If the enum is a part of a class use <I>"%enum
    ClassName::Enum_Type"</I> and the enums will be accessed in wxLua as
    <I>"wx.ClassName.ENUM_ITEM1"</I>.</LI>
  </UL><B><I>%function FUNCTION(int value, ...)</I></B>

  <UL>
    <LI>Declares a global C style function in the binding table which can be
    accessed in wxLua using <I>wx.FUNCTION(int value, ...)</I>.</LI>

    <LI>An example of this is in <I>bindings/wxwidgets/datetime.i</I>,
    <I>"%function wxString wxNow()"</I>.</LI>
  </UL><B><I>%gc</I></B>

  <UL>
    <LI>For use before a userdata parameter of a function or its return value
    only.</LI>

    <LI>Declares that the parameter passed to the function or return value
    should be garbage collected or able to be delete()ed by the Lua
    program.</LI>

    <LI>This is for C++ functions that when passed a userdata object will
    'release' it from being deleted by something else and now it is up to wxLua
    to delete it to avoid a memory leak. This can also be used for return
    values.</LI>

    <LI>You should verify that the generated code is appropriate as this has
    only been implemented for pointers '*'. It can be extened for other cases
    as they needed, please send a message to the wxlua-users mailing list with
    your special circumstances.</LI>

    <LI>Note that by default, functions that return a pointer '*' or a
    reference '&amp;' do NOT add the return value to the list of objects to be
    garbage collected even if it is a <I>%class</I> data type with the
    <I>%delete</I> tag. This is because it is assumed that the return value is
    'owned' by someone else that will delete it. Use the <I>%gc</I> tag to
    override this behavior.</LI>

    <LI>See also <I>%ungc</I>.</LI>
  </UL><B><I>%gc_this</I></B><BR>

  <UL>
    <LI>For a class member functions only and is typically not necessary to
    have for classes that use the <I>%delete</I> tag.</LI>

    <LI>Declares that after calling this function the object itself (not return
    value) should be garbage collected by Lua.</LI>

    <LI>This is for functions that when called will release the object from
    being deleted by something else and therefore it should be deleted in wxLua
    by either the garbage collector or when a Lua program calls the delete()
    function on it.</LI>

    <LI>You should verify that the generated code is appropriate as this has
    only been implemented for return pointers '*'. It can be extened for other
    cases as they needed, please send a message to the wxlua-users mailing list
    with your special circumstances.</LI>

    <LI>See also <I>%ungc_this</I>.</LI>
  </UL><I><B>%if wxLUA_USE_XXX &amp; %__WXMSW__</B></I><BR>
  <I>Interface file data...</I> <B><I>%endif wxLUA_USE_XXX</I></B>

  <UL>
    <LI>The C++ generated code within this block will be surrounded by <I>"#if
    wxLUA_USE_XXX &amp;&amp; __WXMSW__" ... #endif</I>.</LI>

    <LI>You can use any #defined value in the %if statement as well as the
    operators !, &amp;, |.</LI>
  </UL><B><I>%include "headerfile.h"</I></B>

  <UL>
    <LI>Include a C/C++ header file by generating the C code <I>#include
    "headerfile.h"</I>.</LI>
  </UL><B><I>%includefile interfacefile.i - DEPRECATED and probably does not
  work</I></B>

  <UL>
    <LI>Includes another wrapper file that is added to the list of files to
    process.</LI>
  </UL><B><I>%member int m_x</I></B>

  <UL>
    <LI>Declare a property to access member variables in a class.</LI>

    <LI>This tag must be used inside of the <I>%class</I> tag.</LI>

    <LI>The variables will be accessible only using the '.' convention as if
    they were table members.</LI>

    <LI>If the variable is const, it is only read-only.</LI>
  </UL><B><I>%member_func int m_x</I></B>

  <UL>
    <LI>Declare a function to access member variables in a class.</LI>

    <LI>This tag must be used inside of the <I>%class</I> tag.</LI>

    <LI>The generated functions in the example above will be named Get_m_x()
    and Set_m_x(int x) therefore it is recommended that you use <I>%rename</I>
    in conjunction with <I>%member</I>.</LI>

    <LI>For example, in wxPoint <I>"%rename X %member int x"</I> will generate
    wxPoint methods named <SPAN style="font-style: italic;">"pt:GetX()"</SPAN>
    and <SPAN style="font-style: italic;">"pt:SetX(5)"</SPAN> for the wxPoint
    class as well as properties to access them as if they were table members,
    <SPAN style="font-style: italic;">print(pt:x)</SPAN> and <SPAN style=
    "font-style: italic;">"pt:x = 5"</SPAN>.</LI>
  </UL><I><B>%operator bool operator==(const wxPoint&amp; otherPt)
  const</B></I><BR>

  <UL>
    <LI>Declare that the operator == is defined for the class which can be
    accessed in wxLua using <I>point:op_eq(otherPoint)</I>.</LI>

    <LI>This tag must be used inside of the %class tag.</LI>

    <LI>The functions that will be generated for the declared operators use the
    semantics given below.</LI>

    <LI>The reason that the operators are not overridden in Lua using the
    metatable is that Lua only defines a limited set of operators. Having some
    operators overridden and some not is probably more confusing that not
    overriding any. Secondly, by leaving the Lua operators alone the = and ==
    operators (for example) can be useful as userdata pointer assignment and
    pointer comparisons respectively. This is equivalent to using pointers in
    C, as in <I>"wxPoint *pt = &amp;otherPt"</I>, which merely increases the
    ref count of the object and is useful as is.</LI>
  </UL>

  <UL>
    <LI>"==" = "op_eq"</LI>

    <LI>"!=" = "op_ne"</LI>

    <LI>"&lt;" = "op_lt"</LI>

    <LI>"&gt;" = "op_gt"</LI>

    <LI>"&lt;=" = "op_le"</LI>

    <LI>"&gt;=" = "op_ge"</LI>

    <LI>"||" = "op_lor" note: "lor" stands for logical (boolean) or, same for
    "land."</LI>

    <LI>"&amp;&amp;" = "op_land"</LI>

    <LI>"!" = "op_not"</LI>
  </UL>

  <UL>
    <LI>"|" = "op_or"</LI>

    <LI>"&amp;" = "op_and"</LI>

    <LI>"^" = "op_xor"</LI>

    <LI>"&lt;&lt;" = "op_lshift"</LI>

    <LI>"&gt;&gt;" = "op_rshift"</LI>
  </UL>

  <UL>
    <LI>"|=" = "op_ior"</LI>

    <LI>"&amp;=" = "op_iand"</LI>

    <LI>"^=" = "op_ixor"</LI>

    <LI>"&lt;&lt;=" = "op_ilshift"</LI>

    <LI>"&gt;&gt;=" = "op_irshift"</LI>
  </UL>

  <UL>
    <LI>"++" = "op_inc"</LI>

    <LI>"--" = "op_dec"</LI>

    <LI>"- (unary)" = "op_neg"</LI>

    <LI>"~ (unary)" = "op_comp"</LI>

    <LI>"[]" = "op_index"</LI>

    <LI>"()" = "op_func"</LI>
  </UL>

  <UL>
    <LI>"=" = op_set</LI>

    <LI>"+" = "op_add"</LI>

    <LI>"-" = "op_sub"</LI>

    <LI>"*" = "op_mul"</LI>

    <LI>"/" = "op_div"</LI>

    <LI>"%" = "op_mod"</LI>
  </UL>

  <UL>
    <LI>"+=" = "op_iadd" note: ixxx stands for "inplace" as it modifies the
    original object.</LI>

    <LI>"-=" = "op_isub"</LI>

    <LI>"*=" = "op_imul"</LI>

    <LI>"/=" = "op_idiv"</LI>

    <LI>"%=" = "op_imod"</LI>
  </UL><I><B>%not_overload int FUNC_NAME(int value)</B></I><BR>

  <UL>
    <LI>Declare to the binding generator that even though the FUNC_NAME
    function has two or more different signatures to not generate code to
    overload it.</LI>

    <LI>This can be used when a class has two functions with the same name that
    have mutually exclusive #ifdef conditions.</LI>

    <LI>This can happen when, for example, a function is "void DoStuff()" and
    then in a later version of the C++ library "bool DoStuff(int flag)".</LI>
  </UL><I><B>%override wxLua_ClassName_FunctionName</B> // any code or comments
  can go within the %override ... %end block<BR>
  static int LUACALL wxLua_ClassName_FunctionName(lua_State* L)<BR>
  {<BR>
  ...<BR>
  }</I><B><I>%end</I></B>

  <UL>
    <LI>Replace the generated binding code with this handwritten code.</LI>

    <LI>The lines of C++ code between %override and %end is copied verbatim
    into the binding code.</LI>

    <LI>This is necessary for functions that take pointers or references and
    return values though them. Since Lua cannot have values passed by reference
    the only solution is to return multiple values.</LI>

    <LI>See the function wxLua_wxConfigBase_GetNextGroup in
    <I>bindings/wxwidgets/overrides.hpp</I> for an example of this and many
    other examples of when %override is necessary.</LI>

    <LI>The program genwxbind.lua uses the function signature,
    wxLua_ClassName_FunctionName for class member functions, to lookup whether
    there was a %override or not. Therefore, it is important that you get the
    signature correct. The simplest way to get started with your own %override
    is to add the function to your interface files and run <I>genwxbind.lua</I>
    on them. Then look at the C++ output for that function and copy it into
    your %override file and adjust as necessary.</LI>
  </UL><B><I>%override_name CFunctionNameTheOverrideUses</I></B>

  <UL>
    <LI>The binding generator will automatically generate names for the
    functions it binds, which is by default wxLua_ClassName_FunctionName.</LI>

    <LI>There are other special cases, please review the output of the
    generated bindings to determine what the default will be.</LI>

    <LI>However, if the function is overloaded (two or more with same name)
    additional C functions created will have 1,2,3... appended to their
    name.</LI>

    <LI>In order to enforce that the %override that you have written will be
    used for the proper function you can use this tag followed by the exact
    same name you gave the C function in your override.</LI>
  </UL><B><I>%property NAME, read, write</I></B>

  <UL>
    <LI><B>This tag is DEPRECATED and does nothing!</B> These "functions" are
    generated on the fly.</LI>

    <LI>Defines a way to access Get/SetNAME() class member functions as
    variables.</LI>

    <LI>This tag must be used inside of the %class tag.</LI>

    <LI>The Get/SetNAME() functions must exist already.</LI>

    <LI>An example of this is in the wxSize class in
    <I>bindings/wxwidgets/gdi.i</I> where the <I>"%property Height, read,
    write"</I> is declared. In wxLua you can <I>read</I> and <I>write</I> to
    the <I>Height</I> variable using the wxSize::GetHeight() and
    wxSize::SetHeight(int height) as "size = wx.wxSize(1,2); size.Height = 3;
    print(size.Height)". Note that the period, not colon, is used to access the
    property for both reading and writing.</LI>
  </UL><B><I>%rename NEW_FUNC_NAME void FUNC_NAME()</I></B>

  <UL>
    <LI>Rename a C/C++ method to a new name which can be accessed in Lua as
    NEW_FUNC_NAME() though it's accessed in C using FUNC_NAME().</LI>

    <LI>This can be necessary when there are two overloaded C functions that
    are hard or impossible to distinguish between the two and so it is
    necessary to rename them for the Lua script to access them correctly.</LI>

    <LI>An example of when this is necessary is

      <UL>
        <LI>wxSize wxWindow::GetClientSize()</LI>

        <LI>void wxWindow::GetClientSize(int* width, int* height)</LI>

        <LI>Since Lua cannot pass the int *width and *height by reference, we
        change the function to have this signature.

          <UL>
            <LI>[int width, int height] = wxWindow::GetClientSize()</LI>

            <LI>However there is not anyway to distinguish between getting ints
            or a wxSize since we cannot check the left hand side, the return
            values.</LI>

            <LI>The only solution seems to be to %rename the int width, height
            function to GetClientSizeWH()</LI>
          </UL>
        </LI>
      </UL>
    </LI>
  </UL><B><I>%skip</I></B>

  <UL>
    <LI>The next item is skipped, either a single line or a whole class.</LI>
  </UL><I><B>%typedef KNOWN_DATATYPE</B></I> <I><B>UNKNOWN_DATATYPE</B></I>

  <UL>
    <LI>Declares to the binding that the <I>UNKNOWN_DATATYPE</I> should be
    treated as <I>KNOWN_DATATYPE</I>.</LI>

    <LI>An example of this is <I>"%typedef long wxTextCoord"</I> where the
    wxTextCoord is just a long integer.</LI>

    <LI>Without the %typedef the binding generator would give an error about an
    unknown data type, since it would assume that a typo or an error in the
    interface file has been made.</LI>
  </UL><B><I>%ungc</I></B>

  <UL>
    <LI>For use before a userdata parameter of a function or its return value
    only.</LI>

    <LI>Declares that the parameter passed to the function or return value
    should not be garbage collected or able to be delete()ed by the Lua
    program.</LI>

    <LI>This is for functions that when passed a userdata object will take
    'ownership' of it and wxLua should not delete it to avoid double deletion.
    This can also be used for return values.</LI>

    <LI>You should verify that the generated code is appropriate as this has
    only been implemented for pointers '*'. It can be extened for other cases
    as they needed, please send a message to the wxlua-users mailing list with
    your special circumstances.</LI>

    <LI>See also <I>%gc</I>.</LI>
  </UL><I><B>%ungc_this</B></I>

  <UL>
    <LI>For a class member functions only and may be necessary for classes that
    use the <I>%delete</I> tag.</LI>

    <LI>Declares that after calling this function the object itself (not return
    value) will not be garbage collected by Lua.</LI>

    <LI>See also <I>%gc_this</I>.</LI>
  </UL><B><I>%wxchkver_X_Y_Z</I></B><BR>

  <UL>
    <LI>The next item will be <I>#if wxCHECK_VERSION(X,Y,Z).</I></LI>

    <LI>The Y and Z parameters are optional and default to 0.</LI>

    <LI><I>%wxchkverXY is now deprecated, please use %wxchkver_X_Y_Z</I></LI>
  </UL><B><I>%wxcompat_X_Y</I></B>

  <UL>
    <LI>The next item will be <I>#if (defined(WXWIN_COMPATIBILITY_X_Y</I>)
    &amp;&amp; <I>WXWIN_COMPATIBILITY_X_Y)</I>.</LI>

    <LI>The rest of the string beyond "%wxcompat" is appended to
    "WXWIN_COMPATIBILITY" so hopefully all future versions of wxWidgets should
    be supported.</LI>

    <LI><I>%wxcompatXY is now deprecated, please use %wxcompat_X_Y</I></LI>
  </UL><B>These #ifdef conditions are deprecated, use __XXX__ conditions
  directly</B><BR>
  <I><B>%msw</B></I> - the next item will #if defined(__WXMSW__)<B><BR>
  <I>%gtk</I></B> - the next item will #if defined(__WXGTK__)<B><BR>
  <I>%mac</I></B> - the next item will #if defined(__WXMAC__)<B><BR>
  <I>%win</I></B> - the next item will #if defined(__WXMSW__)<B><I>%mgl</I></B>
  - the next item will #if defined(__WXMGL__)<B><BR>
  <I>%motif</I></B> - the next item will #if defined(__WXMOTIF__)<B><BR>
  <I>%univ</I></B> - the next item will #if defined(__WXUNIVERSAL__)<B><BR>
  <I>%x11</I></B> - the next item will #if defined(__WXX11__)<B><BR>
  <I>%cocoa</I></B> - the next item will #if defined(__WXCOCOA__)<B><BR>
  <I>%os2</I></B> - the next item will #if defined(__WXPM__)<B><BR>
  <I>%palm</I></B> - the next item will #if defined(__WXPALMOS__)<B><BR>
  <I>%wince</I></B> - the next item will #if defined(__WXWINCE__)<BR>
  <BR>
  <B>Standard wxWidgets #defines for conditional use using the %if
  directive</B><BR>
  %__WINDOWS__<BR>
  %__WIN16__<BR>
  %__WIN32__<BR>
  %__WIN95__<BR>
  %__WXBASE__<BR>
  %__WXCOCOA__<BR>
  %__WXWINCE__<BR>
  %__WXGTK__<BR>
  %__WXGTK12__<BR>
  %__WXGTK20__<BR>
  %__WXMOTIF__<BR>
  %__WXMOTIF20__<BR>
  %__WXMAC__<BR>
  %__WXMAC_CLASSIC__<BR>
  %__WXMAC_CARBON__<BR>
  %__WXMAC_OSX__<BR>
  %__WXMGL__<BR>
  %__WXMSW__<BR>
  %__WXOS2__<BR>
  %__WXOSX__<BR>
  %__WXPALMOS__<BR>
  %__WXPM__<BR>
  %__WXSTUBS__<BR>
  %__WXXT__<BR>
  %__WXX11__<BR>
  %__WXWINE__<BR>
  %__WXUNIVERSAL__<BR>
  %__X__<BR>
  %__WXWINCE__
</BODY>
</HTML>
